"use strict";
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyticsAdminServiceClient = void 0;
const jsonProtos = require("../../protos/protos.json");
const google_gax_1 = require("google-gax");
/**
 * Client JSON configuration object, loaded from
 * `src/v1alpha/analytics_admin_service_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */
const gapicConfig = require("./analytics_admin_service_client_config.json");
const version = require('../../../package.json').version;
/**
 *  Service Interface for the Google Analytics Admin API.
 * @class
 * @memberof v1alpha
 */
class AnalyticsAdminServiceClient {
    _terminated = false;
    _opts;
    _providedCustomServicePath;
    _gaxModule;
    _gaxGrpc;
    _protos;
    _defaults;
    _universeDomain;
    _servicePath;
    _log = google_gax_1.loggingUtils.log('admin');
    auth;
    descriptors = {
        page: {},
        stream: {},
        longrunning: {},
        batching: {},
    };
    warn;
    innerApiCalls;
    pathTemplates;
    analyticsAdminServiceStub;
    /**
     * Construct an instance of AnalyticsAdminServiceClient.
     *
     * @param {object} [options] - The configuration object.
     * The options accepted by the constructor are described in detail
     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
     * The common options are:
     * @param {object} [options.credentials] - Credentials object.
     * @param {string} [options.credentials.client_email]
     * @param {string} [options.credentials.private_key]
     * @param {string} [options.email] - Account email address. Required when
     *     using a .pem or .p12 keyFilename.
     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
     *     .p12 key downloaded from the Google Developers Console. If you provide
     *     a path to a JSON file, the projectId option below is not necessary.
     *     NOTE: .pem and .p12 require you to specify options.email as well.
     * @param {number} [options.port] - The port on which to connect to
     *     the remote host.
     * @param {string} [options.projectId] - The project ID from the Google
     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
     *     the environment variable GCLOUD_PROJECT for your project ID. If your
     *     app is running in an environment which supports
     *     {@link https://cloud.google.com/docs/authentication/application-default-credentials Application Default Credentials},
     *     your project ID will be detected automatically.
     * @param {string} [options.apiEndpoint] - The domain name of the
     *     API remote host.
     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
     *     Follows the structure of {@link gapicConfig}.
     * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
     *     For more information, please check the
     *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
     * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you
     *     need to avoid loading the default gRPC version and want to use the fallback
     *     HTTP implementation. Load only fallback version and pass it to the constructor:
     *     ```
     *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
     *     const client = new AnalyticsAdminServiceClient({fallback: true}, gax);
     *     ```
     */
    constructor(opts, gaxInstance) {
        // Ensure that options include all the required fields.
        const staticMembers = this.constructor;
        if (opts?.universe_domain && opts?.universeDomain && opts?.universe_domain !== opts?.universeDomain) {
            throw new Error('Please set either universe_domain or universeDomain, but not both.');
        }
        const universeDomainEnvVar = (typeof process === 'object' && typeof process.env === 'object') ? process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] : undefined;
        this._universeDomain = opts?.universeDomain ?? opts?.universe_domain ?? universeDomainEnvVar ?? 'googleapis.com';
        this._servicePath = 'analyticsadmin.' + this._universeDomain;
        const servicePath = opts?.servicePath || opts?.apiEndpoint || this._servicePath;
        this._providedCustomServicePath = !!(opts?.servicePath || opts?.apiEndpoint);
        const port = opts?.port || staticMembers.port;
        const clientConfig = opts?.clientConfig ?? {};
        const fallback = opts?.fallback ?? (typeof window !== 'undefined' && typeof window?.fetch === 'function');
        opts = Object.assign({ servicePath, port, clientConfig, fallback }, opts);
        // Request numeric enum values if REST transport is used.
        opts.numericEnums = true;
        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
        if (servicePath !== this._servicePath && !('scopes' in opts)) {
            opts['scopes'] = staticMembers.scopes;
        }
        // Load google-gax module synchronously if needed
        if (!gaxInstance) {
            gaxInstance = require('google-gax');
        }
        // Choose either gRPC or proto-over-HTTP implementation of google-gax.
        this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;
        // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);
        // Save options to use in initialize() method.
        this._opts = opts;
        // Save the auth object to the client, for use by other methods.
        this.auth = this._gaxGrpc.auth;
        // Set useJWTAccessWithScope on the auth object.
        this.auth.useJWTAccessWithScope = true;
        // Set defaultServicePath on the auth object.
        this.auth.defaultServicePath = this._servicePath;
        // Set the default scopes in auth client if needed.
        if (servicePath === this._servicePath) {
            this.auth.defaultScopes = staticMembers.scopes;
        }
        // Determine the client header string.
        const clientHeader = [
            `gax/${this._gaxModule.version}`,
            `gapic/${version}`,
        ];
        if (typeof process === 'object' && 'versions' in process) {
            clientHeader.push(`gl-node/${process.versions.node}`);
        }
        else {
            clientHeader.push(`gl-web/${this._gaxModule.version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
        }
        else {
            clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }
        // Load the applicable protos.
        this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);
        // This API contains "path templates"; forward-slash-separated
        // identifiers to uniquely identify resources within the API.
        // Create useful helper objects for these.
        this.pathTemplates = {
            accountPathTemplate: new this._gaxModule.PathTemplate('accounts/{account}'),
            accountAccessBindingPathTemplate: new this._gaxModule.PathTemplate('accounts/{account}/accessBindings/{access_binding}'),
            accountSummaryPathTemplate: new this._gaxModule.PathTemplate('accountSummaries/{account_summary}'),
            adSenseLinkPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/adSenseLinks/{adsense_link}'),
            attributionSettingsPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/attributionSettings'),
            audiencePathTemplate: new this._gaxModule.PathTemplate('properties/{property}/audiences/{audience}'),
            bigQueryLinkPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/bigQueryLinks/{bigquery_link}'),
            calculatedMetricPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/calculatedMetrics/{calculated_metric}'),
            channelGroupPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/channelGroups/{channel_group}'),
            conversionEventPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/conversionEvents/{conversion_event}'),
            customDimensionPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/customDimensions/{custom_dimension}'),
            customMetricPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/customMetrics/{custom_metric}'),
            dataRedactionSettingsPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataStreams/{data_stream}/dataRedactionSettings'),
            dataRetentionSettingsPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataRetentionSettings'),
            dataSharingSettingsPathTemplate: new this._gaxModule.PathTemplate('accounts/{account}/dataSharingSettings'),
            dataStreamPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataStreams/{data_stream}'),
            displayVideo360AdvertiserLinkPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/displayVideo360AdvertiserLinks/{display_video_360_advertiser_link}'),
            displayVideo360AdvertiserLinkProposalPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/displayVideo360AdvertiserLinkProposals/{display_video_360_advertiser_link_proposal}'),
            enhancedMeasurementSettingsPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataStreams/{data_stream}/enhancedMeasurementSettings'),
            eventCreateRulePathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataStreams/{data_stream}/eventCreateRules/{event_create_rule}'),
            eventEditRulePathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataStreams/{data_stream}/eventEditRules/{event_edit_rule}'),
            expandedDataSetPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/expandedDataSets/{expanded_data_set}'),
            firebaseLinkPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/firebaseLinks/{firebase_link}'),
            globalSiteTagPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataStreams/{data_stream}/globalSiteTag'),
            googleAdsLinkPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/googleAdsLinks/{google_ads_link}'),
            googleSignalsSettingsPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/googleSignalsSettings'),
            keyEventPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/keyEvents/{key_event}'),
            measurementProtocolSecretPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataStreams/{data_stream}/measurementProtocolSecrets/{measurement_protocol_secret}'),
            propertyPathTemplate: new this._gaxModule.PathTemplate('properties/{property}'),
            propertyAccessBindingPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/accessBindings/{access_binding}'),
            reportingDataAnnotationPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/reportingDataAnnotations/{reporting_data_annotation}'),
            reportingIdentitySettingsPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/reportingIdentitySettings'),
            rollupPropertySourceLinkPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/rollupPropertySourceLinks/{rollup_property_source_link}'),
            sKAdNetworkConversionValueSchemaPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/dataStreams/{data_stream}/sKAdNetworkConversionValueSchema/{skadnetwork_conversion_value_schema}'),
            searchAds360LinkPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/searchAds360Links/{search_ads_360_link}'),
            subpropertyEventFilterPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/subpropertyEventFilters/{sub_property_event_filter}'),
            subpropertySyncConfigPathTemplate: new this._gaxModule.PathTemplate('properties/{property}/subpropertySyncConfigs/{subproperty_sync_config}'),
        };
        // Some of the methods on this service return "paged" results,
        // (e.g. 50 results at a time, with tokens to get subsequent
        // pages). Denote the keys used for pagination and results.
        this.descriptors.page = {
            listAccounts: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'accounts'),
            listAccountSummaries: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'accountSummaries'),
            listProperties: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'properties'),
            listFirebaseLinks: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'firebaseLinks'),
            listGoogleAdsLinks: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'googleAdsLinks'),
            listMeasurementProtocolSecrets: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'measurementProtocolSecrets'),
            listSKAdNetworkConversionValueSchemas: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'skadnetworkConversionValueSchemas'),
            searchChangeHistoryEvents: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'changeHistoryEvents'),
            listConversionEvents: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'conversionEvents'),
            listKeyEvents: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'keyEvents'),
            listDisplayVideo360AdvertiserLinks: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'displayVideo_360AdvertiserLinks'),
            listDisplayVideo360AdvertiserLinkProposals: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'displayVideo_360AdvertiserLinkProposals'),
            listCustomDimensions: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'customDimensions'),
            listCustomMetrics: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'customMetrics'),
            listDataStreams: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'dataStreams'),
            listAudiences: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'audiences'),
            listSearchAds360Links: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'searchAds_360Links'),
            listAccessBindings: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'accessBindings'),
            listExpandedDataSets: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'expandedDataSets'),
            listChannelGroups: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'channelGroups'),
            listBigQueryLinks: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'bigqueryLinks'),
            listAdSenseLinks: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'adsenseLinks'),
            listEventCreateRules: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'eventCreateRules'),
            listEventEditRules: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'eventEditRules'),
            listCalculatedMetrics: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'calculatedMetrics'),
            listRollupPropertySourceLinks: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'rollupPropertySourceLinks'),
            listSubpropertyEventFilters: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'subpropertyEventFilters'),
            listReportingDataAnnotations: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'reportingDataAnnotations'),
            listSubpropertySyncConfigs: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'subpropertySyncConfigs')
        };
        // Put together the default options sent with requests.
        this._defaults = this._gaxGrpc.constructSettings('google.analytics.admin.v1alpha.AnalyticsAdminService', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });
        // Set up a dictionary of "inner API calls"; the core implementation
        // of calling the API is handled in `google-gax`, with this code
        // merely providing the destination and request information.
        this.innerApiCalls = {};
        // Add a warn function to the client constructor so it can be easily tested.
        this.warn = this._gaxModule.warn;
    }
    /**
     * Initialize the client.
     * Performs asynchronous operations (such as authentication) and prepares the client.
     * This function will be called automatically when any class method is called for the
     * first time, but if you need to initialize it before calling an actual method,
     * feel free to call initialize() directly.
     *
     * You can await on this method if you want to make sure the client is initialized.
     *
     * @returns {Promise} A promise that resolves to an authenticated service stub.
     */
    initialize() {
        // If the client stub promise is already initialized, return immediately.
        if (this.analyticsAdminServiceStub) {
            return this.analyticsAdminServiceStub;
        }
        // Put together the "service stub" for
        // google.analytics.admin.v1alpha.AnalyticsAdminService.
        this.analyticsAdminServiceStub = this._gaxGrpc.createStub(this._opts.fallback ?
            this._protos.lookupService('google.analytics.admin.v1alpha.AnalyticsAdminService') :
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this._protos.google.analytics.admin.v1alpha.AnalyticsAdminService, this._opts, this._providedCustomServicePath);
        // Iterate over each of the methods that the service provides
        // and create an API call method for each.
        const analyticsAdminServiceStubMethods = ['getAccount', 'listAccounts', 'deleteAccount', 'updateAccount', 'provisionAccountTicket', 'listAccountSummaries', 'getProperty', 'listProperties', 'createProperty', 'deleteProperty', 'updateProperty', 'createFirebaseLink', 'deleteFirebaseLink', 'listFirebaseLinks', 'getGlobalSiteTag', 'createGoogleAdsLink', 'updateGoogleAdsLink', 'deleteGoogleAdsLink', 'listGoogleAdsLinks', 'getDataSharingSettings', 'getMeasurementProtocolSecret', 'listMeasurementProtocolSecrets', 'createMeasurementProtocolSecret', 'deleteMeasurementProtocolSecret', 'updateMeasurementProtocolSecret', 'acknowledgeUserDataCollection', 'getSkAdNetworkConversionValueSchema', 'createSkAdNetworkConversionValueSchema', 'deleteSkAdNetworkConversionValueSchema', 'updateSkAdNetworkConversionValueSchema', 'listSkAdNetworkConversionValueSchemas', 'searchChangeHistoryEvents', 'getGoogleSignalsSettings', 'updateGoogleSignalsSettings', 'createConversionEvent', 'updateConversionEvent', 'getConversionEvent', 'deleteConversionEvent', 'listConversionEvents', 'createKeyEvent', 'updateKeyEvent', 'getKeyEvent', 'deleteKeyEvent', 'listKeyEvents', 'getDisplayVideo360AdvertiserLink', 'listDisplayVideo360AdvertiserLinks', 'createDisplayVideo360AdvertiserLink', 'deleteDisplayVideo360AdvertiserLink', 'updateDisplayVideo360AdvertiserLink', 'getDisplayVideo360AdvertiserLinkProposal', 'listDisplayVideo360AdvertiserLinkProposals', 'createDisplayVideo360AdvertiserLinkProposal', 'deleteDisplayVideo360AdvertiserLinkProposal', 'approveDisplayVideo360AdvertiserLinkProposal', 'cancelDisplayVideo360AdvertiserLinkProposal', 'createCustomDimension', 'updateCustomDimension', 'listCustomDimensions', 'archiveCustomDimension', 'getCustomDimension', 'createCustomMetric', 'updateCustomMetric', 'listCustomMetrics', 'archiveCustomMetric', 'getCustomMetric', 'getDataRetentionSettings', 'updateDataRetentionSettings', 'createDataStream', 'deleteDataStream', 'updateDataStream', 'listDataStreams', 'getDataStream', 'getAudience', 'listAudiences', 'createAudience', 'updateAudience', 'archiveAudience', 'getSearchAds360Link', 'listSearchAds360Links', 'createSearchAds360Link', 'deleteSearchAds360Link', 'updateSearchAds360Link', 'getAttributionSettings', 'updateAttributionSettings', 'runAccessReport', 'createAccessBinding', 'getAccessBinding', 'updateAccessBinding', 'deleteAccessBinding', 'listAccessBindings', 'batchCreateAccessBindings', 'batchGetAccessBindings', 'batchUpdateAccessBindings', 'batchDeleteAccessBindings', 'getExpandedDataSet', 'listExpandedDataSets', 'createExpandedDataSet', 'updateExpandedDataSet', 'deleteExpandedDataSet', 'getChannelGroup', 'listChannelGroups', 'createChannelGroup', 'updateChannelGroup', 'deleteChannelGroup', 'createBigQueryLink', 'getBigQueryLink', 'listBigQueryLinks', 'deleteBigQueryLink', 'updateBigQueryLink', 'getEnhancedMeasurementSettings', 'updateEnhancedMeasurementSettings', 'getAdSenseLink', 'createAdSenseLink', 'deleteAdSenseLink', 'listAdSenseLinks', 'getEventCreateRule', 'listEventCreateRules', 'createEventCreateRule', 'updateEventCreateRule', 'deleteEventCreateRule', 'getEventEditRule', 'listEventEditRules', 'createEventEditRule', 'updateEventEditRule', 'deleteEventEditRule', 'reorderEventEditRules', 'updateDataRedactionSettings', 'getDataRedactionSettings', 'getCalculatedMetric', 'createCalculatedMetric', 'listCalculatedMetrics', 'updateCalculatedMetric', 'deleteCalculatedMetric', 'createRollupProperty', 'getRollupPropertySourceLink', 'listRollupPropertySourceLinks', 'createRollupPropertySourceLink', 'deleteRollupPropertySourceLink', 'provisionSubproperty', 'createSubpropertyEventFilter', 'getSubpropertyEventFilter', 'listSubpropertyEventFilters', 'updateSubpropertyEventFilter', 'deleteSubpropertyEventFilter', 'createReportingDataAnnotation', 'getReportingDataAnnotation', 'listReportingDataAnnotations', 'updateReportingDataAnnotation', 'deleteReportingDataAnnotation', 'submitUserDeletion', 'listSubpropertySyncConfigs', 'updateSubpropertySyncConfig', 'getSubpropertySyncConfig', 'getReportingIdentitySettings'];
        for (const methodName of analyticsAdminServiceStubMethods) {
            const callPromise = this.analyticsAdminServiceStub.then(stub => (...args) => {
                if (this._terminated) {
                    return Promise.reject('The client has already been closed.');
                }
                const func = stub[methodName];
                return func.apply(stub, args);
            }, (err) => () => {
                throw err;
            });
            const descriptor = this.descriptors.page[methodName] ||
                undefined;
            const apiCall = this._gaxModule.createApiCall(callPromise, this._defaults[methodName], descriptor, this._opts.fallback);
            this.innerApiCalls[methodName] = apiCall;
        }
        return this.analyticsAdminServiceStub;
    }
    /**
     * The DNS address for this API service.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */
    static get servicePath() {
        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            process.emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'analyticsadmin.googleapis.com';
    }
    /**
     * The DNS address for this API service - same as servicePath.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */
    static get apiEndpoint() {
        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            process.emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'analyticsadmin.googleapis.com';
    }
    /**
     * The DNS address for this API service.
     * @returns {string} The DNS address for this service.
     */
    get apiEndpoint() {
        return this._servicePath;
    }
    get universeDomain() {
        return this._universeDomain;
    }
    /**
     * The port for this API service.
     * @returns {number} The default port for this service.
     */
    static get port() {
        return 443;
    }
    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     * @returns {string[]} List of default scopes.
     */
    static get scopes() {
        return [
            'https://www.googleapis.com/auth/analytics.edit',
            'https://www.googleapis.com/auth/analytics.manage.users',
            'https://www.googleapis.com/auth/analytics.manage.users.readonly',
            'https://www.googleapis.com/auth/analytics.readonly'
        ];
    }
    /**
     * Return the project ID used by this class.
     * @returns {Promise} A promise that resolves to string containing the project ID.
     */
    getProjectId(callback) {
        if (callback) {
            this.auth.getProjectId(callback);
            return;
        }
        return this.auth.getProjectId();
    }
    getAccount(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getAccount request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getAccount response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getAccount(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getAccount response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteAccount(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteAccount request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteAccount response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteAccount(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteAccount response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateAccount(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'account.name': request.account.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateAccount request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateAccount response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateAccount(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateAccount response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    provisionAccountTicket(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize().catch(err => { throw err; });
        this._log.info('provisionAccountTicket request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('provisionAccountTicket response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.provisionAccountTicket(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('provisionAccountTicket response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getProperty(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getProperty request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getProperty response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getProperty(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getProperty response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createProperty(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize().catch(err => { throw err; });
        this._log.info('createProperty request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createProperty response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createProperty(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createProperty response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteProperty(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteProperty request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteProperty response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteProperty(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteProperty response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateProperty(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'property.name': request.property.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateProperty request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateProperty response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateProperty(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateProperty response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createFirebaseLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createFirebaseLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createFirebaseLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createFirebaseLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createFirebaseLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteFirebaseLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteFirebaseLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteFirebaseLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteFirebaseLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteFirebaseLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getGlobalSiteTag(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getGlobalSiteTag request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getGlobalSiteTag response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getGlobalSiteTag(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getGlobalSiteTag response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createGoogleAdsLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createGoogleAdsLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createGoogleAdsLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createGoogleAdsLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createGoogleAdsLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateGoogleAdsLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'google_ads_link.name': request.googleAdsLink.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateGoogleAdsLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateGoogleAdsLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateGoogleAdsLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateGoogleAdsLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteGoogleAdsLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteGoogleAdsLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteGoogleAdsLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteGoogleAdsLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteGoogleAdsLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getDataSharingSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getDataSharingSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getDataSharingSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getDataSharingSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getDataSharingSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getMeasurementProtocolSecret(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getMeasurementProtocolSecret request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getMeasurementProtocolSecret response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getMeasurementProtocolSecret(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getMeasurementProtocolSecret response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createMeasurementProtocolSecret(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createMeasurementProtocolSecret request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createMeasurementProtocolSecret response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createMeasurementProtocolSecret(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createMeasurementProtocolSecret response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteMeasurementProtocolSecret(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteMeasurementProtocolSecret request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteMeasurementProtocolSecret response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteMeasurementProtocolSecret(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteMeasurementProtocolSecret response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateMeasurementProtocolSecret(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'measurement_protocol_secret.name': request.measurementProtocolSecret.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateMeasurementProtocolSecret request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateMeasurementProtocolSecret response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateMeasurementProtocolSecret(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateMeasurementProtocolSecret response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    acknowledgeUserDataCollection(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'property': request.property ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('acknowledgeUserDataCollection request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('acknowledgeUserDataCollection response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.acknowledgeUserDataCollection(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('acknowledgeUserDataCollection response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getSKAdNetworkConversionValueSchema(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getSKAdNetworkConversionValueSchema request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getSKAdNetworkConversionValueSchema response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getSkAdNetworkConversionValueSchema(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getSKAdNetworkConversionValueSchema response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createSKAdNetworkConversionValueSchema(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createSKAdNetworkConversionValueSchema request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createSKAdNetworkConversionValueSchema response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createSkAdNetworkConversionValueSchema(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createSKAdNetworkConversionValueSchema response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteSKAdNetworkConversionValueSchema(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteSKAdNetworkConversionValueSchema request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteSKAdNetworkConversionValueSchema response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteSkAdNetworkConversionValueSchema(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteSKAdNetworkConversionValueSchema response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateSKAdNetworkConversionValueSchema(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'skadnetwork_conversion_value_schema.name': request.skadnetworkConversionValueSchema.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateSKAdNetworkConversionValueSchema request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateSKAdNetworkConversionValueSchema response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateSkAdNetworkConversionValueSchema(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateSKAdNetworkConversionValueSchema response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getGoogleSignalsSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getGoogleSignalsSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getGoogleSignalsSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getGoogleSignalsSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getGoogleSignalsSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateGoogleSignalsSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'google_signals_settings.name': request.googleSignalsSettings.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateGoogleSignalsSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateGoogleSignalsSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateGoogleSignalsSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateGoogleSignalsSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createConversionEvent(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this.warn('DEP$AnalyticsAdminService-$CreateConversionEvent', 'CreateConversionEvent is deprecated and may be removed in a future version.', 'DeprecationWarning');
        this._log.info('createConversionEvent request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createConversionEvent response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createConversionEvent(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createConversionEvent response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateConversionEvent(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'conversion_event.name': request.conversionEvent.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this.warn('DEP$AnalyticsAdminService-$UpdateConversionEvent', 'UpdateConversionEvent is deprecated and may be removed in a future version.', 'DeprecationWarning');
        this._log.info('updateConversionEvent request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateConversionEvent response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateConversionEvent(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateConversionEvent response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getConversionEvent(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this.warn('DEP$AnalyticsAdminService-$GetConversionEvent', 'GetConversionEvent is deprecated and may be removed in a future version.', 'DeprecationWarning');
        this._log.info('getConversionEvent request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getConversionEvent response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getConversionEvent(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getConversionEvent response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteConversionEvent(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this.warn('DEP$AnalyticsAdminService-$DeleteConversionEvent', 'DeleteConversionEvent is deprecated and may be removed in a future version.', 'DeprecationWarning');
        this._log.info('deleteConversionEvent request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteConversionEvent response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteConversionEvent(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteConversionEvent response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createKeyEvent(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createKeyEvent request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createKeyEvent response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createKeyEvent(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createKeyEvent response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateKeyEvent(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'key_event.name': request.keyEvent.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateKeyEvent request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateKeyEvent response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateKeyEvent(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateKeyEvent response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getKeyEvent(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getKeyEvent request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getKeyEvent response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getKeyEvent(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getKeyEvent response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteKeyEvent(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteKeyEvent request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteKeyEvent response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteKeyEvent(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteKeyEvent response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getDisplayVideo360AdvertiserLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getDisplayVideo360AdvertiserLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getDisplayVideo360AdvertiserLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getDisplayVideo360AdvertiserLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getDisplayVideo360AdvertiserLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createDisplayVideo360AdvertiserLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createDisplayVideo360AdvertiserLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createDisplayVideo360AdvertiserLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createDisplayVideo360AdvertiserLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createDisplayVideo360AdvertiserLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteDisplayVideo360AdvertiserLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteDisplayVideo360AdvertiserLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteDisplayVideo360AdvertiserLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteDisplayVideo360AdvertiserLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteDisplayVideo360AdvertiserLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateDisplayVideo360AdvertiserLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'display_video_360_advertiser_link.name': request.displayVideo_360AdvertiserLink.name?.toString() ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateDisplayVideo360AdvertiserLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateDisplayVideo360AdvertiserLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateDisplayVideo360AdvertiserLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateDisplayVideo360AdvertiserLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getDisplayVideo360AdvertiserLinkProposal(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getDisplayVideo360AdvertiserLinkProposal request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getDisplayVideo360AdvertiserLinkProposal response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getDisplayVideo360AdvertiserLinkProposal(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getDisplayVideo360AdvertiserLinkProposal response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createDisplayVideo360AdvertiserLinkProposal(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createDisplayVideo360AdvertiserLinkProposal request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createDisplayVideo360AdvertiserLinkProposal response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createDisplayVideo360AdvertiserLinkProposal(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createDisplayVideo360AdvertiserLinkProposal response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteDisplayVideo360AdvertiserLinkProposal(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteDisplayVideo360AdvertiserLinkProposal request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteDisplayVideo360AdvertiserLinkProposal response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteDisplayVideo360AdvertiserLinkProposal(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteDisplayVideo360AdvertiserLinkProposal response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    approveDisplayVideo360AdvertiserLinkProposal(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('approveDisplayVideo360AdvertiserLinkProposal request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('approveDisplayVideo360AdvertiserLinkProposal response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.approveDisplayVideo360AdvertiserLinkProposal(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('approveDisplayVideo360AdvertiserLinkProposal response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    cancelDisplayVideo360AdvertiserLinkProposal(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('cancelDisplayVideo360AdvertiserLinkProposal request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('cancelDisplayVideo360AdvertiserLinkProposal response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.cancelDisplayVideo360AdvertiserLinkProposal(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('cancelDisplayVideo360AdvertiserLinkProposal response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createCustomDimension(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createCustomDimension request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createCustomDimension response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createCustomDimension(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createCustomDimension response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateCustomDimension(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'custom_dimension.name': request.customDimension.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateCustomDimension request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateCustomDimension response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateCustomDimension(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateCustomDimension response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    archiveCustomDimension(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('archiveCustomDimension request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('archiveCustomDimension response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.archiveCustomDimension(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('archiveCustomDimension response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getCustomDimension(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getCustomDimension request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getCustomDimension response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getCustomDimension(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getCustomDimension response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createCustomMetric(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createCustomMetric request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createCustomMetric response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createCustomMetric(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createCustomMetric response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateCustomMetric(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'custom_metric.name': request.customMetric.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateCustomMetric request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateCustomMetric response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateCustomMetric(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateCustomMetric response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    archiveCustomMetric(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('archiveCustomMetric request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('archiveCustomMetric response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.archiveCustomMetric(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('archiveCustomMetric response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getCustomMetric(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getCustomMetric request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getCustomMetric response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getCustomMetric(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getCustomMetric response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getDataRetentionSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getDataRetentionSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getDataRetentionSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getDataRetentionSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getDataRetentionSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateDataRetentionSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'data_retention_settings.name': request.dataRetentionSettings.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateDataRetentionSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateDataRetentionSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateDataRetentionSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateDataRetentionSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createDataStream(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createDataStream request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createDataStream response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createDataStream(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createDataStream response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteDataStream(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteDataStream request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteDataStream response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteDataStream(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteDataStream response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateDataStream(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'data_stream.name': request.dataStream.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateDataStream request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateDataStream response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateDataStream(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateDataStream response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getDataStream(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getDataStream request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getDataStream response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getDataStream(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getDataStream response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getAudience(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getAudience request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getAudience response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getAudience(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getAudience response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createAudience(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createAudience request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createAudience response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createAudience(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createAudience response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateAudience(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'audience.name': request.audience.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateAudience request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateAudience response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateAudience(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateAudience response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    archiveAudience(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('archiveAudience request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('archiveAudience response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.archiveAudience(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('archiveAudience response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getSearchAds360Link(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getSearchAds360Link request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getSearchAds360Link response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getSearchAds360Link(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getSearchAds360Link response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createSearchAds360Link(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createSearchAds360Link request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createSearchAds360Link response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createSearchAds360Link(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createSearchAds360Link response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteSearchAds360Link(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteSearchAds360Link request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteSearchAds360Link response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteSearchAds360Link(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteSearchAds360Link response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateSearchAds360Link(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'search_ads_360_link.name': request.searchAds_360Link.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateSearchAds360Link request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateSearchAds360Link response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateSearchAds360Link(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateSearchAds360Link response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getAttributionSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getAttributionSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getAttributionSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getAttributionSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getAttributionSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateAttributionSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'attribution_settings.name': request.attributionSettings.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateAttributionSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateAttributionSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateAttributionSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateAttributionSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    runAccessReport(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'entity': request.entity ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('runAccessReport request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('runAccessReport response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.runAccessReport(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('runAccessReport response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createAccessBinding(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createAccessBinding request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createAccessBinding response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createAccessBinding(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createAccessBinding response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getAccessBinding(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getAccessBinding request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getAccessBinding response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getAccessBinding(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getAccessBinding response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateAccessBinding(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'access_binding.name': request.accessBinding.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateAccessBinding request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateAccessBinding response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateAccessBinding(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateAccessBinding response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteAccessBinding(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteAccessBinding request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteAccessBinding response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteAccessBinding(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteAccessBinding response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    batchCreateAccessBindings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('batchCreateAccessBindings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('batchCreateAccessBindings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.batchCreateAccessBindings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('batchCreateAccessBindings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    batchGetAccessBindings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('batchGetAccessBindings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('batchGetAccessBindings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.batchGetAccessBindings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('batchGetAccessBindings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    batchUpdateAccessBindings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('batchUpdateAccessBindings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('batchUpdateAccessBindings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.batchUpdateAccessBindings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('batchUpdateAccessBindings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    batchDeleteAccessBindings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('batchDeleteAccessBindings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('batchDeleteAccessBindings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.batchDeleteAccessBindings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('batchDeleteAccessBindings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getExpandedDataSet(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getExpandedDataSet request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getExpandedDataSet response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getExpandedDataSet(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getExpandedDataSet response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createExpandedDataSet(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createExpandedDataSet request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createExpandedDataSet response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createExpandedDataSet(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createExpandedDataSet response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateExpandedDataSet(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'expanded_data_set.name': request.expandedDataSet.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateExpandedDataSet request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateExpandedDataSet response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateExpandedDataSet(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateExpandedDataSet response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteExpandedDataSet(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteExpandedDataSet request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteExpandedDataSet response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteExpandedDataSet(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteExpandedDataSet response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getChannelGroup(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getChannelGroup request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getChannelGroup response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getChannelGroup(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getChannelGroup response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createChannelGroup(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createChannelGroup request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createChannelGroup response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createChannelGroup(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createChannelGroup response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateChannelGroup(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'channel_group.name': request.channelGroup.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateChannelGroup request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateChannelGroup response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateChannelGroup(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateChannelGroup response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteChannelGroup(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteChannelGroup request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteChannelGroup response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteChannelGroup(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteChannelGroup response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createBigQueryLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createBigQueryLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createBigQueryLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createBigQueryLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createBigQueryLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getBigQueryLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getBigQueryLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getBigQueryLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getBigQueryLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getBigQueryLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteBigQueryLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteBigQueryLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteBigQueryLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteBigQueryLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteBigQueryLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateBigQueryLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'bigquery_link.name': request.bigqueryLink.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateBigQueryLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateBigQueryLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateBigQueryLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateBigQueryLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getEnhancedMeasurementSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getEnhancedMeasurementSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getEnhancedMeasurementSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getEnhancedMeasurementSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getEnhancedMeasurementSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateEnhancedMeasurementSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'enhanced_measurement_settings.name': request.enhancedMeasurementSettings.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateEnhancedMeasurementSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateEnhancedMeasurementSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateEnhancedMeasurementSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateEnhancedMeasurementSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getAdSenseLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getAdSenseLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getAdSenseLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getAdSenseLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getAdSenseLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createAdSenseLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createAdSenseLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createAdSenseLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createAdSenseLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createAdSenseLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteAdSenseLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteAdSenseLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteAdSenseLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteAdSenseLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteAdSenseLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getEventCreateRule(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getEventCreateRule request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getEventCreateRule response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getEventCreateRule(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getEventCreateRule response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createEventCreateRule(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createEventCreateRule request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createEventCreateRule response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createEventCreateRule(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createEventCreateRule response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateEventCreateRule(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'event_create_rule.name': request.eventCreateRule.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateEventCreateRule request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateEventCreateRule response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateEventCreateRule(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateEventCreateRule response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteEventCreateRule(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteEventCreateRule request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteEventCreateRule response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteEventCreateRule(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteEventCreateRule response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getEventEditRule(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getEventEditRule request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getEventEditRule response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getEventEditRule(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getEventEditRule response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createEventEditRule(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createEventEditRule request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createEventEditRule response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createEventEditRule(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createEventEditRule response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateEventEditRule(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'event_edit_rule.name': request.eventEditRule.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateEventEditRule request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateEventEditRule response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateEventEditRule(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateEventEditRule response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteEventEditRule(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteEventEditRule request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteEventEditRule response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteEventEditRule(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteEventEditRule response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    reorderEventEditRules(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('reorderEventEditRules request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('reorderEventEditRules response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.reorderEventEditRules(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('reorderEventEditRules response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateDataRedactionSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'data_redaction_settings.name': request.dataRedactionSettings.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateDataRedactionSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateDataRedactionSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateDataRedactionSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateDataRedactionSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getDataRedactionSettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getDataRedactionSettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getDataRedactionSettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getDataRedactionSettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getDataRedactionSettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getCalculatedMetric(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getCalculatedMetric request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getCalculatedMetric response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getCalculatedMetric(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getCalculatedMetric response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createCalculatedMetric(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createCalculatedMetric request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createCalculatedMetric response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createCalculatedMetric(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createCalculatedMetric response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateCalculatedMetric(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'calculated_metric.name': request.calculatedMetric.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateCalculatedMetric request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateCalculatedMetric response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateCalculatedMetric(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateCalculatedMetric response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteCalculatedMetric(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteCalculatedMetric request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteCalculatedMetric response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteCalculatedMetric(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteCalculatedMetric response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createRollupProperty(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize().catch(err => { throw err; });
        this._log.info('createRollupProperty request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createRollupProperty response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createRollupProperty(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createRollupProperty response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getRollupPropertySourceLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getRollupPropertySourceLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getRollupPropertySourceLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getRollupPropertySourceLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getRollupPropertySourceLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createRollupPropertySourceLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createRollupPropertySourceLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createRollupPropertySourceLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createRollupPropertySourceLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createRollupPropertySourceLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteRollupPropertySourceLink(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteRollupPropertySourceLink request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteRollupPropertySourceLink response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteRollupPropertySourceLink(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteRollupPropertySourceLink response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    provisionSubproperty(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize().catch(err => { throw err; });
        this._log.info('provisionSubproperty request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('provisionSubproperty response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.provisionSubproperty(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('provisionSubproperty response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createSubpropertyEventFilter(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createSubpropertyEventFilter request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createSubpropertyEventFilter response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createSubpropertyEventFilter(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createSubpropertyEventFilter response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getSubpropertyEventFilter(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getSubpropertyEventFilter request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getSubpropertyEventFilter response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getSubpropertyEventFilter(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getSubpropertyEventFilter response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateSubpropertyEventFilter(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'subproperty_event_filter.name': request.subpropertyEventFilter.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateSubpropertyEventFilter request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateSubpropertyEventFilter response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateSubpropertyEventFilter(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateSubpropertyEventFilter response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteSubpropertyEventFilter(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteSubpropertyEventFilter request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteSubpropertyEventFilter response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteSubpropertyEventFilter(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteSubpropertyEventFilter response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    createReportingDataAnnotation(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('createReportingDataAnnotation request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('createReportingDataAnnotation response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.createReportingDataAnnotation(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('createReportingDataAnnotation response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getReportingDataAnnotation(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getReportingDataAnnotation request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getReportingDataAnnotation response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getReportingDataAnnotation(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getReportingDataAnnotation response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateReportingDataAnnotation(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'reporting_data_annotation.name': request.reportingDataAnnotation.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateReportingDataAnnotation request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateReportingDataAnnotation response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateReportingDataAnnotation(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateReportingDataAnnotation response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    deleteReportingDataAnnotation(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('deleteReportingDataAnnotation request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('deleteReportingDataAnnotation response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.deleteReportingDataAnnotation(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('deleteReportingDataAnnotation response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    submitUserDeletion(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('submitUserDeletion request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('submitUserDeletion response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.submitUserDeletion(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('submitUserDeletion response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    updateSubpropertySyncConfig(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'subproperty_sync_config.name': request.subpropertySyncConfig.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('updateSubpropertySyncConfig request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('updateSubpropertySyncConfig response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.updateSubpropertySyncConfig(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('updateSubpropertySyncConfig response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getSubpropertySyncConfig(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getSubpropertySyncConfig request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getSubpropertySyncConfig response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getSubpropertySyncConfig(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getSubpropertySyncConfig response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    getReportingIdentitySettings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'name': request.name ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this._log.info('getReportingIdentitySettings request %j', request);
        const wrappedCallback = callback
            ? (error, response, options, rawResponse) => {
                this._log.info('getReportingIdentitySettings response %j', response);
                callback(error, response, options, rawResponse); // We verified callback above.
            }
            : undefined;
        return this.innerApiCalls.getReportingIdentitySettings(request, options, wrappedCallback)
            ?.then(([response, options, rawResponse]) => {
            this._log.info('getReportingIdentitySettings response %j', response);
            return [response, options, rawResponse];
        }).catch((error) => {
            if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
                const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
                error.statusDetails = (0, google_gax_1.decodeAnyProtosInArray)(error.statusDetails, protos);
            }
            throw error;
        });
    }
    listAccounts(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listAccounts values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listAccounts request %j', request);
        return this.innerApiCalls
            .listAccounts(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listAccounts values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listAccounts`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListAccounts` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListAccounts` must
     *   match the call that provided the page token.
     * @param {boolean} request.showDeleted
     *   Whether to include soft-deleted (ie: "trashed") Accounts in the
     *   results. Accounts can be inspected to determine whether they are deleted or
     *   not.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.Account|Account} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listAccountsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listAccountsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listAccounts'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAccounts stream %j', request);
        return this.descriptors.page.listAccounts.createStream(this.innerApiCalls.listAccounts, request, callSettings);
    }
    /**
     * Equivalent to `listAccounts`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListAccounts` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListAccounts` must
     *   match the call that provided the page token.
     * @param {boolean} request.showDeleted
     *   Whether to include soft-deleted (ie: "trashed") Accounts in the
     *   results. Accounts can be inspected to determine whether they are deleted or
     *   not.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.Account|Account}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_accounts.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListAccounts_async
     */
    listAccountsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listAccounts'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAccounts iterate %j', request);
        return this.descriptors.page.listAccounts.asyncIterate(this.innerApiCalls['listAccounts'], request, callSettings);
    }
    listAccountSummaries(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listAccountSummaries values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listAccountSummaries request %j', request);
        return this.innerApiCalls
            .listAccountSummaries(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listAccountSummaries values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listAccountSummaries`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {number} request.pageSize
     *   The maximum number of AccountSummary resources to return. The service may
     *   return fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListAccountSummaries` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListAccountSummaries`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.AccountSummary|AccountSummary} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listAccountSummariesAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listAccountSummariesStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listAccountSummaries'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAccountSummaries stream %j', request);
        return this.descriptors.page.listAccountSummaries.createStream(this.innerApiCalls.listAccountSummaries, request, callSettings);
    }
    /**
     * Equivalent to `listAccountSummaries`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {number} request.pageSize
     *   The maximum number of AccountSummary resources to return. The service may
     *   return fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListAccountSummaries` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListAccountSummaries`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.AccountSummary|AccountSummary}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_account_summaries.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListAccountSummaries_async
     */
    listAccountSummariesAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listAccountSummaries'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAccountSummaries iterate %j', request);
        return this.descriptors.page.listAccountSummaries.asyncIterate(this.innerApiCalls['listAccountSummaries'], request, callSettings);
    }
    listProperties(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listProperties values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listProperties request %j', request);
        return this.innerApiCalls
            .listProperties(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listProperties values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listProperties`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.filter
     *   Required. An expression for filtering the results of the request.
     *   Fields eligible for filtering are:
     *   `parent:`(The resource name of the parent account/property) or
     *   `ancestor:`(The resource name of the parent account) or
     *   `firebase_project:`(The id or number of the linked firebase project).
     *   Some examples of filters:
     *
     *   ```
     *   | Filter                      | Description                               |
     *   |-----------------------------|-------------------------------------------|
     *   | parent:accounts/123         | The account with account id: 123.       |
     *   | parent:properties/123       | The property with property id: 123.       |
     *   | ancestor:accounts/123       | The account with account id: 123.         |
     *   | firebase_project:project-id | The firebase project with id: project-id. |
     *   | firebase_project:123        | The firebase project with number: 123.    |
     *   ```
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListProperties` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListProperties` must
     *   match the call that provided the page token.
     * @param {boolean} request.showDeleted
     *   Whether to include soft-deleted (ie: "trashed") Properties in the
     *   results. Properties can be inspected to determine whether they are deleted
     *   or not.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.Property|Property} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listPropertiesAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listPropertiesStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listProperties'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listProperties stream %j', request);
        return this.descriptors.page.listProperties.createStream(this.innerApiCalls.listProperties, request, callSettings);
    }
    /**
     * Equivalent to `listProperties`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.filter
     *   Required. An expression for filtering the results of the request.
     *   Fields eligible for filtering are:
     *   `parent:`(The resource name of the parent account/property) or
     *   `ancestor:`(The resource name of the parent account) or
     *   `firebase_project:`(The id or number of the linked firebase project).
     *   Some examples of filters:
     *
     *   ```
     *   | Filter                      | Description                               |
     *   |-----------------------------|-------------------------------------------|
     *   | parent:accounts/123         | The account with account id: 123.       |
     *   | parent:properties/123       | The property with property id: 123.       |
     *   | ancestor:accounts/123       | The account with account id: 123.         |
     *   | firebase_project:project-id | The firebase project with id: project-id. |
     *   | firebase_project:123        | The firebase project with number: 123.    |
     *   ```
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListProperties` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListProperties` must
     *   match the call that provided the page token.
     * @param {boolean} request.showDeleted
     *   Whether to include soft-deleted (ie: "trashed") Properties in the
     *   results. Properties can be inspected to determine whether they are deleted
     *   or not.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.Property|Property}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_properties.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListProperties_async
     */
    listPropertiesAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listProperties'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listProperties iterate %j', request);
        return this.descriptors.page.listProperties.asyncIterate(this.innerApiCalls['listProperties'], request, callSettings);
    }
    listFirebaseLinks(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listFirebaseLinks values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listFirebaseLinks request %j', request);
        return this.innerApiCalls
            .listFirebaseLinks(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listFirebaseLinks values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listFirebaseLinks`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Format: properties/{property_id}
     *
     *   Example: `properties/1234`
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListFirebaseLinks` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListFirebaseLinks` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.FirebaseLink|FirebaseLink} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listFirebaseLinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listFirebaseLinksStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listFirebaseLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listFirebaseLinks stream %j', request);
        return this.descriptors.page.listFirebaseLinks.createStream(this.innerApiCalls.listFirebaseLinks, request, callSettings);
    }
    /**
     * Equivalent to `listFirebaseLinks`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Format: properties/{property_id}
     *
     *   Example: `properties/1234`
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListFirebaseLinks` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListFirebaseLinks` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.FirebaseLink|FirebaseLink}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_firebase_links.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListFirebaseLinks_async
     */
    listFirebaseLinksAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listFirebaseLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listFirebaseLinks iterate %j', request);
        return this.descriptors.page.listFirebaseLinks.asyncIterate(this.innerApiCalls['listFirebaseLinks'], request, callSettings);
    }
    listGoogleAdsLinks(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listGoogleAdsLinks values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listGoogleAdsLinks request %j', request);
        return this.innerApiCalls
            .listGoogleAdsLinks(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listGoogleAdsLinks values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listGoogleAdsLinks`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListGoogleAdsLinks` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListGoogleAdsLinks` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.GoogleAdsLink|GoogleAdsLink} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listGoogleAdsLinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listGoogleAdsLinksStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listGoogleAdsLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listGoogleAdsLinks stream %j', request);
        return this.descriptors.page.listGoogleAdsLinks.createStream(this.innerApiCalls.listGoogleAdsLinks, request, callSettings);
    }
    /**
     * Equivalent to `listGoogleAdsLinks`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListGoogleAdsLinks` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListGoogleAdsLinks` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.GoogleAdsLink|GoogleAdsLink}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_google_ads_links.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListGoogleAdsLinks_async
     */
    listGoogleAdsLinksAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listGoogleAdsLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listGoogleAdsLinks iterate %j', request);
        return this.descriptors.page.listGoogleAdsLinks.asyncIterate(this.innerApiCalls['listGoogleAdsLinks'], request, callSettings);
    }
    listMeasurementProtocolSecrets(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listMeasurementProtocolSecrets values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listMeasurementProtocolSecrets request %j', request);
        return this.innerApiCalls
            .listMeasurementProtocolSecrets(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listMeasurementProtocolSecrets values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listMeasurementProtocolSecrets`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The resource name of the parent stream.
     *   Format:
     *   properties/{property}/dataStreams/{dataStream}/measurementProtocolSecrets
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 10 resources will be returned.
     *   The maximum value is 10. Higher values will be coerced to the maximum.
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListMeasurementProtocolSecrets`
     *   call. Provide this to retrieve the subsequent page. When paginating, all
     *   other parameters provided to `ListMeasurementProtocolSecrets` must match
     *   the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.MeasurementProtocolSecret|MeasurementProtocolSecret} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listMeasurementProtocolSecretsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listMeasurementProtocolSecretsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listMeasurementProtocolSecrets'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listMeasurementProtocolSecrets stream %j', request);
        return this.descriptors.page.listMeasurementProtocolSecrets.createStream(this.innerApiCalls.listMeasurementProtocolSecrets, request, callSettings);
    }
    /**
     * Equivalent to `listMeasurementProtocolSecrets`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The resource name of the parent stream.
     *   Format:
     *   properties/{property}/dataStreams/{dataStream}/measurementProtocolSecrets
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 10 resources will be returned.
     *   The maximum value is 10. Higher values will be coerced to the maximum.
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListMeasurementProtocolSecrets`
     *   call. Provide this to retrieve the subsequent page. When paginating, all
     *   other parameters provided to `ListMeasurementProtocolSecrets` must match
     *   the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.MeasurementProtocolSecret|MeasurementProtocolSecret}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_measurement_protocol_secrets.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListMeasurementProtocolSecrets_async
     */
    listMeasurementProtocolSecretsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listMeasurementProtocolSecrets'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listMeasurementProtocolSecrets iterate %j', request);
        return this.descriptors.page.listMeasurementProtocolSecrets.asyncIterate(this.innerApiCalls['listMeasurementProtocolSecrets'], request, callSettings);
    }
    listSKAdNetworkConversionValueSchemas(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listSKAdNetworkConversionValueSchemas values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listSKAdNetworkConversionValueSchemas request %j', request);
        return this.innerApiCalls
            .listSkAdNetworkConversionValueSchemas(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listSKAdNetworkConversionValueSchemas values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listSKAdNetworkConversionValueSchemas`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The DataStream resource to list schemas for.
     *   Format:
     *   properties/{property_id}/dataStreams/{dataStream}
     *   Example: properties/1234/dataStreams/5678
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous
     *   `ListSKAdNetworkConversionValueSchemas` call. Provide this to retrieve the
     *   subsequent page. When paginating, all other parameters provided to
     *   `ListSKAdNetworkConversionValueSchema` must match the call that provided
     *   the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.SKAdNetworkConversionValueSchema|SKAdNetworkConversionValueSchema} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listSKAdNetworkConversionValueSchemasAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listSKAdNetworkConversionValueSchemasStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listSkAdNetworkConversionValueSchemas'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listSKAdNetworkConversionValueSchemas stream %j', request);
        return this.descriptors.page.listSKAdNetworkConversionValueSchemas.createStream(this.innerApiCalls.listSkAdNetworkConversionValueSchemas, request, callSettings);
    }
    /**
     * Equivalent to `listSKAdNetworkConversionValueSchemas`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The DataStream resource to list schemas for.
     *   Format:
     *   properties/{property_id}/dataStreams/{dataStream}
     *   Example: properties/1234/dataStreams/5678
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous
     *   `ListSKAdNetworkConversionValueSchemas` call. Provide this to retrieve the
     *   subsequent page. When paginating, all other parameters provided to
     *   `ListSKAdNetworkConversionValueSchema` must match the call that provided
     *   the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.SKAdNetworkConversionValueSchema|SKAdNetworkConversionValueSchema}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_s_k_ad_network_conversion_value_schemas.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListSKAdNetworkConversionValueSchemas_async
     */
    listSKAdNetworkConversionValueSchemasAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listSkAdNetworkConversionValueSchemas'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listSKAdNetworkConversionValueSchemas iterate %j', request);
        return this.descriptors.page.listSKAdNetworkConversionValueSchemas.asyncIterate(this.innerApiCalls['listSkAdNetworkConversionValueSchemas'], request, callSettings);
    }
    searchChangeHistoryEvents(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'account': request.account ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('searchChangeHistoryEvents values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('searchChangeHistoryEvents request %j', request);
        return this.innerApiCalls
            .searchChangeHistoryEvents(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('searchChangeHistoryEvents values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `searchChangeHistoryEvents`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.account
     *   Required. The account resource for which to return change history
     *   resources. Format: accounts/{account}
     *
     *   Example: `accounts/100`
     * @param {string} [request.property]
     *   Optional. Resource name for a child property. If set, only return changes
     *   made to this property or its child resources.
     *   Format: properties/{propertyId}
     *
     *   Example: `properties/100`
     * @param {number[]} [request.resourceType]
     *   Optional. If set, only return changes if they are for a resource that
     *   matches at least one of these types.
     * @param {number[]} [request.action]
     *   Optional. If set, only return changes that match one or more of these types
     *   of actions.
     * @param {string[]} [request.actorEmail]
     *   Optional. If set, only return changes if they are made by a user in this
     *   list.
     * @param {google.protobuf.Timestamp} [request.earliestChangeTime]
     *   Optional. If set, only return changes made after this time (inclusive).
     * @param {google.protobuf.Timestamp} [request.latestChangeTime]
     *   Optional. If set, only return changes made before this time (inclusive).
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of ChangeHistoryEvent items to return.
     *   If unspecified, at most 50 items will be returned. The maximum value is 200
     *   (higher values will be coerced to the maximum).
     *
     *   Note that the service may return a page with fewer items than this value
     *   specifies (potentially even zero), and that there still may be additional
     *   pages. If you want a particular number of items, you'll need to continue
     *   requesting additional pages using `page_token` until you get the needed
     *   number.
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `SearchChangeHistoryEvents` call. Provide this to retrieve the subsequent
     *   page. When paginating, all other parameters provided to
     *   `SearchChangeHistoryEvents` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.ChangeHistoryEvent|ChangeHistoryEvent} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `searchChangeHistoryEventsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    searchChangeHistoryEventsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'account': request.account ?? '',
        });
        const defaultCallSettings = this._defaults['searchChangeHistoryEvents'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('searchChangeHistoryEvents stream %j', request);
        return this.descriptors.page.searchChangeHistoryEvents.createStream(this.innerApiCalls.searchChangeHistoryEvents, request, callSettings);
    }
    /**
     * Equivalent to `searchChangeHistoryEvents`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.account
     *   Required. The account resource for which to return change history
     *   resources. Format: accounts/{account}
     *
     *   Example: `accounts/100`
     * @param {string} [request.property]
     *   Optional. Resource name for a child property. If set, only return changes
     *   made to this property or its child resources.
     *   Format: properties/{propertyId}
     *
     *   Example: `properties/100`
     * @param {number[]} [request.resourceType]
     *   Optional. If set, only return changes if they are for a resource that
     *   matches at least one of these types.
     * @param {number[]} [request.action]
     *   Optional. If set, only return changes that match one or more of these types
     *   of actions.
     * @param {string[]} [request.actorEmail]
     *   Optional. If set, only return changes if they are made by a user in this
     *   list.
     * @param {google.protobuf.Timestamp} [request.earliestChangeTime]
     *   Optional. If set, only return changes made after this time (inclusive).
     * @param {google.protobuf.Timestamp} [request.latestChangeTime]
     *   Optional. If set, only return changes made before this time (inclusive).
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of ChangeHistoryEvent items to return.
     *   If unspecified, at most 50 items will be returned. The maximum value is 200
     *   (higher values will be coerced to the maximum).
     *
     *   Note that the service may return a page with fewer items than this value
     *   specifies (potentially even zero), and that there still may be additional
     *   pages. If you want a particular number of items, you'll need to continue
     *   requesting additional pages using `page_token` until you get the needed
     *   number.
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `SearchChangeHistoryEvents` call. Provide this to retrieve the subsequent
     *   page. When paginating, all other parameters provided to
     *   `SearchChangeHistoryEvents` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.ChangeHistoryEvent|ChangeHistoryEvent}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.search_change_history_events.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_SearchChangeHistoryEvents_async
     */
    searchChangeHistoryEventsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'account': request.account ?? '',
        });
        const defaultCallSettings = this._defaults['searchChangeHistoryEvents'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('searchChangeHistoryEvents iterate %j', request);
        return this.descriptors.page.searchChangeHistoryEvents.asyncIterate(this.innerApiCalls['searchChangeHistoryEvents'], request, callSettings);
    }
    listConversionEvents(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        this.warn('DEP$AnalyticsAdminService-$ListConversionEvents', 'ListConversionEvents is deprecated and may be removed in a future version.', 'DeprecationWarning');
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listConversionEvents values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listConversionEvents request %j', request);
        return this.innerApiCalls
            .listConversionEvents(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listConversionEvents values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listConversionEvents`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The resource name of the parent property.
     *   Example: 'properties/123'
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListConversionEvents` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListConversionEvents`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.ConversionEvent|ConversionEvent} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listConversionEventsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @deprecated ListConversionEvents is deprecated and may be removed in a future version.
     */
    listConversionEventsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listConversionEvents'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this.warn('DEP$AnalyticsAdminService-$ListConversionEvents', 'ListConversionEvents is deprecated and may be removed in a future version.', 'DeprecationWarning');
        this._log.info('listConversionEvents stream %j', request);
        return this.descriptors.page.listConversionEvents.createStream(this.innerApiCalls.listConversionEvents, request, callSettings);
    }
    /**
     * Equivalent to `listConversionEvents`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The resource name of the parent property.
     *   Example: 'properties/123'
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListConversionEvents` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListConversionEvents`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.ConversionEvent|ConversionEvent}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_conversion_events.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListConversionEvents_async
     * @deprecated ListConversionEvents is deprecated and may be removed in a future version.
     */
    listConversionEventsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listConversionEvents'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this.warn('DEP$AnalyticsAdminService-$ListConversionEvents', 'ListConversionEvents is deprecated and may be removed in a future version.', 'DeprecationWarning');
        this._log.info('listConversionEvents iterate %j', request);
        return this.descriptors.page.listConversionEvents.asyncIterate(this.innerApiCalls['listConversionEvents'], request, callSettings);
    }
    listKeyEvents(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listKeyEvents values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listKeyEvents request %j', request);
        return this.innerApiCalls
            .listKeyEvents(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listKeyEvents values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listKeyEvents`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The resource name of the parent property.
     *   Example: 'properties/123'
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListKeyEvents` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListKeyEvents`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.KeyEvent|KeyEvent} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listKeyEventsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listKeyEventsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listKeyEvents'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listKeyEvents stream %j', request);
        return this.descriptors.page.listKeyEvents.createStream(this.innerApiCalls.listKeyEvents, request, callSettings);
    }
    /**
     * Equivalent to `listKeyEvents`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The resource name of the parent property.
     *   Example: 'properties/123'
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListKeyEvents` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListKeyEvents`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.KeyEvent|KeyEvent}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_key_events.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListKeyEvents_async
     */
    listKeyEventsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listKeyEvents'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listKeyEvents iterate %j', request);
        return this.descriptors.page.listKeyEvents.asyncIterate(this.innerApiCalls['listKeyEvents'], request, callSettings);
    }
    listDisplayVideo360AdvertiserLinks(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listDisplayVideo360AdvertiserLinks values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listDisplayVideo360AdvertiserLinks request %j', request);
        return this.innerApiCalls
            .listDisplayVideo360AdvertiserLinks(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listDisplayVideo360AdvertiserLinks values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listDisplayVideo360AdvertiserLinks`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListDisplayVideo360AdvertiserLinks`
     *   call. Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to
     *   `ListDisplayVideo360AdvertiserLinks` must match the call that provided the
     *   page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.DisplayVideo360AdvertiserLink|DisplayVideo360AdvertiserLink} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listDisplayVideo360AdvertiserLinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listDisplayVideo360AdvertiserLinksStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listDisplayVideo360AdvertiserLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listDisplayVideo360AdvertiserLinks stream %j', request);
        return this.descriptors.page.listDisplayVideo360AdvertiserLinks.createStream(this.innerApiCalls.listDisplayVideo360AdvertiserLinks, request, callSettings);
    }
    /**
     * Equivalent to `listDisplayVideo360AdvertiserLinks`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListDisplayVideo360AdvertiserLinks`
     *   call. Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to
     *   `ListDisplayVideo360AdvertiserLinks` must match the call that provided the
     *   page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.DisplayVideo360AdvertiserLink|DisplayVideo360AdvertiserLink}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_display_video360_advertiser_links.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListDisplayVideo360AdvertiserLinks_async
     */
    listDisplayVideo360AdvertiserLinksAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listDisplayVideo360AdvertiserLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listDisplayVideo360AdvertiserLinks iterate %j', request);
        return this.descriptors.page.listDisplayVideo360AdvertiserLinks.asyncIterate(this.innerApiCalls['listDisplayVideo360AdvertiserLinks'], request, callSettings);
    }
    listDisplayVideo360AdvertiserLinkProposals(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listDisplayVideo360AdvertiserLinkProposals values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listDisplayVideo360AdvertiserLinkProposals request %j', request);
        return this.innerApiCalls
            .listDisplayVideo360AdvertiserLinkProposals(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listDisplayVideo360AdvertiserLinkProposals values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listDisplayVideo360AdvertiserLinkProposals`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous
     *   `ListDisplayVideo360AdvertiserLinkProposals` call. Provide this to retrieve
     *   the subsequent page.
     *
     *   When paginating, all other parameters provided to
     *   `ListDisplayVideo360AdvertiserLinkProposals` must match the call that
     *   provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.DisplayVideo360AdvertiserLinkProposal|DisplayVideo360AdvertiserLinkProposal} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listDisplayVideo360AdvertiserLinkProposalsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listDisplayVideo360AdvertiserLinkProposalsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listDisplayVideo360AdvertiserLinkProposals'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listDisplayVideo360AdvertiserLinkProposals stream %j', request);
        return this.descriptors.page.listDisplayVideo360AdvertiserLinkProposals.createStream(this.innerApiCalls.listDisplayVideo360AdvertiserLinkProposals, request, callSettings);
    }
    /**
     * Equivalent to `listDisplayVideo360AdvertiserLinkProposals`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous
     *   `ListDisplayVideo360AdvertiserLinkProposals` call. Provide this to retrieve
     *   the subsequent page.
     *
     *   When paginating, all other parameters provided to
     *   `ListDisplayVideo360AdvertiserLinkProposals` must match the call that
     *   provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.DisplayVideo360AdvertiserLinkProposal|DisplayVideo360AdvertiserLinkProposal}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_display_video360_advertiser_link_proposals.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListDisplayVideo360AdvertiserLinkProposals_async
     */
    listDisplayVideo360AdvertiserLinkProposalsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listDisplayVideo360AdvertiserLinkProposals'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listDisplayVideo360AdvertiserLinkProposals iterate %j', request);
        return this.descriptors.page.listDisplayVideo360AdvertiserLinkProposals.asyncIterate(this.innerApiCalls['listDisplayVideo360AdvertiserLinkProposals'], request, callSettings);
    }
    listCustomDimensions(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listCustomDimensions values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listCustomDimensions request %j', request);
        return this.innerApiCalls
            .listCustomDimensions(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listCustomDimensions values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listCustomDimensions`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListCustomDimensions` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListCustomDimensions`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.CustomDimension|CustomDimension} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listCustomDimensionsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listCustomDimensionsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listCustomDimensions'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listCustomDimensions stream %j', request);
        return this.descriptors.page.listCustomDimensions.createStream(this.innerApiCalls.listCustomDimensions, request, callSettings);
    }
    /**
     * Equivalent to `listCustomDimensions`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListCustomDimensions` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListCustomDimensions`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.CustomDimension|CustomDimension}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_custom_dimensions.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListCustomDimensions_async
     */
    listCustomDimensionsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listCustomDimensions'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listCustomDimensions iterate %j', request);
        return this.descriptors.page.listCustomDimensions.asyncIterate(this.innerApiCalls['listCustomDimensions'], request, callSettings);
    }
    listCustomMetrics(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listCustomMetrics values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listCustomMetrics request %j', request);
        return this.innerApiCalls
            .listCustomMetrics(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listCustomMetrics values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listCustomMetrics`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListCustomMetrics` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListCustomMetrics` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.CustomMetric|CustomMetric} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listCustomMetricsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listCustomMetricsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listCustomMetrics'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listCustomMetrics stream %j', request);
        return this.descriptors.page.listCustomMetrics.createStream(this.innerApiCalls.listCustomMetrics, request, callSettings);
    }
    /**
     * Equivalent to `listCustomMetrics`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListCustomMetrics` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListCustomMetrics` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.CustomMetric|CustomMetric}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_custom_metrics.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListCustomMetrics_async
     */
    listCustomMetricsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listCustomMetrics'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listCustomMetrics iterate %j', request);
        return this.descriptors.page.listCustomMetrics.asyncIterate(this.innerApiCalls['listCustomMetrics'], request, callSettings);
    }
    listDataStreams(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listDataStreams values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listDataStreams request %j', request);
        return this.innerApiCalls
            .listDataStreams(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listDataStreams values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listDataStreams`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListDataStreams` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListDataStreams` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.DataStream|DataStream} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listDataStreamsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listDataStreamsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listDataStreams'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listDataStreams stream %j', request);
        return this.descriptors.page.listDataStreams.createStream(this.innerApiCalls.listDataStreams, request, callSettings);
    }
    /**
     * Equivalent to `listDataStreams`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListDataStreams` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListDataStreams` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.DataStream|DataStream}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_data_streams.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListDataStreams_async
     */
    listDataStreamsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listDataStreams'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listDataStreams iterate %j', request);
        return this.descriptors.page.listDataStreams.asyncIterate(this.innerApiCalls['listDataStreams'], request, callSettings);
    }
    listAudiences(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listAudiences values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listAudiences request %j', request);
        return this.innerApiCalls
            .listAudiences(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listAudiences values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listAudiences`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListAudiences` call. Provide this
     *   to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListAudiences` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.Audience|Audience} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listAudiencesAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listAudiencesStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listAudiences'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAudiences stream %j', request);
        return this.descriptors.page.listAudiences.createStream(this.innerApiCalls.listAudiences, request, callSettings);
    }
    /**
     * Equivalent to `listAudiences`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListAudiences` call. Provide this
     *   to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListAudiences` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.Audience|Audience}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_audiences.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListAudiences_async
     */
    listAudiencesAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listAudiences'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAudiences iterate %j', request);
        return this.descriptors.page.listAudiences.asyncIterate(this.innerApiCalls['listAudiences'], request, callSettings);
    }
    listSearchAds360Links(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listSearchAds360Links values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listSearchAds360Links request %j', request);
        return this.innerApiCalls
            .listSearchAds360Links(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listSearchAds360Links values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listSearchAds360Links`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListSearchAds360Links`
     *   call. Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to
     *   `ListSearchAds360Links` must match the call that provided the
     *   page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.SearchAds360Link|SearchAds360Link} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listSearchAds360LinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listSearchAds360LinksStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listSearchAds360Links'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listSearchAds360Links stream %j', request);
        return this.descriptors.page.listSearchAds360Links.createStream(this.innerApiCalls.listSearchAds360Links, request, callSettings);
    }
    /**
     * Equivalent to `listSearchAds360Links`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListSearchAds360Links`
     *   call. Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to
     *   `ListSearchAds360Links` must match the call that provided the
     *   page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.SearchAds360Link|SearchAds360Link}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_search_ads360_links.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListSearchAds360Links_async
     */
    listSearchAds360LinksAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listSearchAds360Links'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listSearchAds360Links iterate %j', request);
        return this.descriptors.page.listSearchAds360Links.asyncIterate(this.innerApiCalls['listSearchAds360Links'], request, callSettings);
    }
    listAccessBindings(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listAccessBindings values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listAccessBindings request %j', request);
        return this.innerApiCalls
            .listAccessBindings(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listAccessBindings values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listAccessBindings`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Formats:
     *   - accounts/{account}
     *   - properties/{property}
     * @param {number} request.pageSize
     *   The maximum number of access bindings to return.
     *   The service may return fewer than this value.
     *   If unspecified, at most 200 access bindings will be returned.
     *   The maximum value is 500; values above 500 will be coerced to 500.
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListAccessBindings` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListAccessBindings` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.AccessBinding|AccessBinding} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listAccessBindingsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listAccessBindingsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listAccessBindings'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAccessBindings stream %j', request);
        return this.descriptors.page.listAccessBindings.createStream(this.innerApiCalls.listAccessBindings, request, callSettings);
    }
    /**
     * Equivalent to `listAccessBindings`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Formats:
     *   - accounts/{account}
     *   - properties/{property}
     * @param {number} request.pageSize
     *   The maximum number of access bindings to return.
     *   The service may return fewer than this value.
     *   If unspecified, at most 200 access bindings will be returned.
     *   The maximum value is 500; values above 500 will be coerced to 500.
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListAccessBindings` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListAccessBindings` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.AccessBinding|AccessBinding}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_access_bindings.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListAccessBindings_async
     */
    listAccessBindingsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listAccessBindings'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAccessBindings iterate %j', request);
        return this.descriptors.page.listAccessBindings.asyncIterate(this.innerApiCalls['listAccessBindings'], request, callSettings);
    }
    listExpandedDataSets(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listExpandedDataSets values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listExpandedDataSets request %j', request);
        return this.innerApiCalls
            .listExpandedDataSets(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listExpandedDataSets values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listExpandedDataSets`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListExpandedDataSets` call. Provide
     *   this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListExpandedDataSet`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.ExpandedDataSet|ExpandedDataSet} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listExpandedDataSetsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listExpandedDataSetsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listExpandedDataSets'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listExpandedDataSets stream %j', request);
        return this.descriptors.page.listExpandedDataSets.createStream(this.innerApiCalls.listExpandedDataSets, request, callSettings);
    }
    /**
     * Equivalent to `listExpandedDataSets`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListExpandedDataSets` call. Provide
     *   this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListExpandedDataSet`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.ExpandedDataSet|ExpandedDataSet}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_expanded_data_sets.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListExpandedDataSets_async
     */
    listExpandedDataSetsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listExpandedDataSets'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listExpandedDataSets iterate %j', request);
        return this.descriptors.page.listExpandedDataSets.asyncIterate(this.innerApiCalls['listExpandedDataSets'], request, callSettings);
    }
    listChannelGroups(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listChannelGroups values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listChannelGroups request %j', request);
        return this.innerApiCalls
            .listChannelGroups(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listChannelGroups values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listChannelGroups`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The property for which to list ChannelGroups.
     *   Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListChannelGroups` call. Provide
     *   this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListChannelGroups`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.ChannelGroup|ChannelGroup} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listChannelGroupsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listChannelGroupsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listChannelGroups'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listChannelGroups stream %j', request);
        return this.descriptors.page.listChannelGroups.createStream(this.innerApiCalls.listChannelGroups, request, callSettings);
    }
    /**
     * Equivalent to `listChannelGroups`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The property for which to list ChannelGroups.
     *   Example format: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListChannelGroups` call. Provide
     *   this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListChannelGroups`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.ChannelGroup|ChannelGroup}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_channel_groups.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListChannelGroups_async
     */
    listChannelGroupsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listChannelGroups'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listChannelGroups iterate %j', request);
        return this.descriptors.page.listChannelGroups.asyncIterate(this.innerApiCalls['listChannelGroups'], request, callSettings);
    }
    listBigQueryLinks(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listBigQueryLinks values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listBigQueryLinks request %j', request);
        return this.innerApiCalls
            .listBigQueryLinks(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listBigQueryLinks values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listBigQueryLinks`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The name of the property to list BigQuery links under.
     *   Format: properties/{property_id}
     *   Example: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListBigQueryLinks` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListBigQueryLinks` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.BigQueryLink|BigQueryLink} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listBigQueryLinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listBigQueryLinksStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listBigQueryLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listBigQueryLinks stream %j', request);
        return this.descriptors.page.listBigQueryLinks.createStream(this.innerApiCalls.listBigQueryLinks, request, callSettings);
    }
    /**
     * Equivalent to `listBigQueryLinks`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The name of the property to list BigQuery links under.
     *   Format: properties/{property_id}
     *   Example: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListBigQueryLinks` call.
     *   Provide this to retrieve the subsequent page.
     *   When paginating, all other parameters provided to `ListBigQueryLinks` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.BigQueryLink|BigQueryLink}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_big_query_links.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListBigQueryLinks_async
     */
    listBigQueryLinksAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listBigQueryLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listBigQueryLinks iterate %j', request);
        return this.descriptors.page.listBigQueryLinks.asyncIterate(this.innerApiCalls['listBigQueryLinks'], request, callSettings);
    }
    listAdSenseLinks(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listAdSenseLinks values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listAdSenseLinks request %j', request);
        return this.innerApiCalls
            .listAdSenseLinks(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listAdSenseLinks values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listAdSenseLinks`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Resource name of the parent property.
     *   Format: properties/{propertyId}
     *   Example: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token received from a previous `ListAdSenseLinks` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListAdSenseLinks` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.AdSenseLink|AdSenseLink} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listAdSenseLinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listAdSenseLinksStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listAdSenseLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAdSenseLinks stream %j', request);
        return this.descriptors.page.listAdSenseLinks.createStream(this.innerApiCalls.listAdSenseLinks, request, callSettings);
    }
    /**
     * Equivalent to `listAdSenseLinks`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Resource name of the parent property.
     *   Format: properties/{propertyId}
     *   Example: properties/1234
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token received from a previous `ListAdSenseLinks` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListAdSenseLinks` must
     *   match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.AdSenseLink|AdSenseLink}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_ad_sense_links.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListAdSenseLinks_async
     */
    listAdSenseLinksAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listAdSenseLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listAdSenseLinks iterate %j', request);
        return this.descriptors.page.listAdSenseLinks.asyncIterate(this.innerApiCalls['listAdSenseLinks'], request, callSettings);
    }
    listEventCreateRules(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listEventCreateRules values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listEventCreateRules request %j', request);
        return this.innerApiCalls
            .listEventCreateRules(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listEventCreateRules values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listEventCreateRules`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/123/dataStreams/456
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListEventCreateRules` call. Provide
     *   this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListEventCreateRules`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.EventCreateRule|EventCreateRule} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listEventCreateRulesAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listEventCreateRulesStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listEventCreateRules'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listEventCreateRules stream %j', request);
        return this.descriptors.page.listEventCreateRules.createStream(this.innerApiCalls.listEventCreateRules, request, callSettings);
    }
    /**
     * Equivalent to `listEventCreateRules`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/123/dataStreams/456
     * @param {number} request.pageSize
     *   The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} request.pageToken
     *   A page token, received from a previous `ListEventCreateRules` call. Provide
     *   this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListEventCreateRules`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.EventCreateRule|EventCreateRule}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_event_create_rules.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListEventCreateRules_async
     */
    listEventCreateRulesAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listEventCreateRules'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listEventCreateRules iterate %j', request);
        return this.descriptors.page.listEventCreateRules.asyncIterate(this.innerApiCalls['listEventCreateRules'], request, callSettings);
    }
    listEventEditRules(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listEventEditRules values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listEventEditRules request %j', request);
        return this.innerApiCalls
            .listEventEditRules(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listEventEditRules values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listEventEditRules`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/123/dataStreams/456
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous `ListEventEditRules` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListEventEditRules`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.EventEditRule|EventEditRule} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listEventEditRulesAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listEventEditRulesStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listEventEditRules'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listEventEditRules stream %j', request);
        return this.descriptors.page.listEventEditRules.createStream(this.innerApiCalls.listEventEditRules, request, callSettings);
    }
    /**
     * Equivalent to `listEventEditRules`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/123/dataStreams/456
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous `ListEventEditRules` call.
     *   Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListEventEditRules`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.EventEditRule|EventEditRule}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_event_edit_rules.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListEventEditRules_async
     */
    listEventEditRulesAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listEventEditRules'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listEventEditRules iterate %j', request);
        return this.descriptors.page.listEventEditRules.asyncIterate(this.innerApiCalls['listEventEditRules'], request, callSettings);
    }
    listCalculatedMetrics(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listCalculatedMetrics values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listCalculatedMetrics request %j', request);
        return this.innerApiCalls
            .listCalculatedMetrics(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listCalculatedMetrics values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listCalculatedMetrics`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous `ListCalculatedMetrics`
     *   call. Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListCalculatedMetrics`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.CalculatedMetric|CalculatedMetric} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listCalculatedMetricsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listCalculatedMetricsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listCalculatedMetrics'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listCalculatedMetrics stream %j', request);
        return this.descriptors.page.listCalculatedMetrics.createStream(this.innerApiCalls.listCalculatedMetrics, request, callSettings);
    }
    /**
     * Equivalent to `listCalculatedMetrics`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Example format: properties/1234
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200 (higher values will be coerced to the maximum).
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous `ListCalculatedMetrics`
     *   call. Provide this to retrieve the subsequent page.
     *
     *   When paginating, all other parameters provided to `ListCalculatedMetrics`
     *   must match the call that provided the page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.CalculatedMetric|CalculatedMetric}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_calculated_metrics.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListCalculatedMetrics_async
     */
    listCalculatedMetricsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listCalculatedMetrics'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listCalculatedMetrics iterate %j', request);
        return this.descriptors.page.listCalculatedMetrics.asyncIterate(this.innerApiCalls['listCalculatedMetrics'], request, callSettings);
    }
    listRollupPropertySourceLinks(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listRollupPropertySourceLinks values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listRollupPropertySourceLinks request %j', request);
        return this.innerApiCalls
            .listRollupPropertySourceLinks(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listRollupPropertySourceLinks values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listRollupPropertySourceLinks`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The name of the roll-up property to list roll-up property source
     *   links under. Format: properties/{property_id} Example: properties/1234
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `ListRollupPropertySourceLinks` call. Provide this to retrieve the
     *   subsequent page. When paginating, all other parameters provided to
     *   `ListRollupPropertySourceLinks` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.RollupPropertySourceLink|RollupPropertySourceLink} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listRollupPropertySourceLinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listRollupPropertySourceLinksStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listRollupPropertySourceLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listRollupPropertySourceLinks stream %j', request);
        return this.descriptors.page.listRollupPropertySourceLinks.createStream(this.innerApiCalls.listRollupPropertySourceLinks, request, callSettings);
    }
    /**
     * Equivalent to `listRollupPropertySourceLinks`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The name of the roll-up property to list roll-up property source
     *   links under. Format: properties/{property_id} Example: properties/1234
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages.
     *   If unspecified, at most 50 resources will be returned.
     *   The maximum value is 200; (higher values will be coerced to the maximum)
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `ListRollupPropertySourceLinks` call. Provide this to retrieve the
     *   subsequent page. When paginating, all other parameters provided to
     *   `ListRollupPropertySourceLinks` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.RollupPropertySourceLink|RollupPropertySourceLink}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_rollup_property_source_links.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListRollupPropertySourceLinks_async
     */
    listRollupPropertySourceLinksAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listRollupPropertySourceLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listRollupPropertySourceLinks iterate %j', request);
        return this.descriptors.page.listRollupPropertySourceLinks.asyncIterate(this.innerApiCalls['listRollupPropertySourceLinks'], request, callSettings);
    }
    listSubpropertyEventFilters(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listSubpropertyEventFilters values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listSubpropertyEventFilters request %j', request);
        return this.innerApiCalls
            .listSubpropertyEventFilters(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listSubpropertyEventFilters values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listSubpropertyEventFilters`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Resource name of the ordinary property.
     *   Format: properties/property_id
     *   Example: properties/123
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages. If unspecified,
     *   at most 50 resources will be returned. The maximum value is 200; (higher
     *   values will be coerced to the maximum)
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `ListSubpropertyEventFilters` call. Provide this to retrieve the subsequent
     *   page. When paginating, all other parameters provided to
     *   `ListSubpropertyEventFilters` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.SubpropertyEventFilter|SubpropertyEventFilter} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listSubpropertyEventFiltersAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listSubpropertyEventFiltersStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listSubpropertyEventFilters'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listSubpropertyEventFilters stream %j', request);
        return this.descriptors.page.listSubpropertyEventFilters.createStream(this.innerApiCalls.listSubpropertyEventFilters, request, callSettings);
    }
    /**
     * Equivalent to `listSubpropertyEventFilters`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Resource name of the ordinary property.
     *   Format: properties/property_id
     *   Example: properties/123
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages. If unspecified,
     *   at most 50 resources will be returned. The maximum value is 200; (higher
     *   values will be coerced to the maximum)
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `ListSubpropertyEventFilters` call. Provide this to retrieve the subsequent
     *   page. When paginating, all other parameters provided to
     *   `ListSubpropertyEventFilters` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.SubpropertyEventFilter|SubpropertyEventFilter}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_subproperty_event_filters.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListSubpropertyEventFilters_async
     */
    listSubpropertyEventFiltersAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listSubpropertyEventFilters'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listSubpropertyEventFilters iterate %j', request);
        return this.descriptors.page.listSubpropertyEventFilters.asyncIterate(this.innerApiCalls['listSubpropertyEventFilters'], request, callSettings);
    }
    listReportingDataAnnotations(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listReportingDataAnnotations values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listReportingDataAnnotations request %j', request);
        return this.innerApiCalls
            .listReportingDataAnnotations(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listReportingDataAnnotations values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listReportingDataAnnotations`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Resource name of the property.
     *   Format: properties/property_id
     *   Example: properties/123
     * @param {string} [request.filter]
     *   Optional. Filter that restricts which reporting data annotations under the
     *   parent property are listed.
     *
     *   Supported fields are:
     *
     *     * 'name'
     *     * `title`
     *     * `description`
     *     * `annotation_date`
     *     * `annotation_date_range`
     *     * `color`
     *
     *   Additionally, this API provides the following helper functions:
     *
     *     * annotation_duration() : the duration that this annotation marks,
     *     [durations](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/duration.proto).
     *     expect a numeric representation of seconds followed by an `s` suffix.
     *     * is_annotation_in_range(start_date, end_date)  : if the annotation is in
     *     the range specified by the `start_date` and `end_date`. The dates are in
     *     ISO-8601 format, for example `2031-06-28`.
     *
     *   Supported operations:
     *
     *   * `=` : equals
     *   * `!=` : not equals
     *   * `<` : less than
     *   * `>` : greater than
     *   * `<=` :  less than or equals
     *   * `>=` : greater than or equals
     *   * `:` : has operator
     *   * `=~` : [regular expression](https://github.com/google/re2/wiki/Syntax)
     *   match
     *   * `!~` : [regular expression](https://github.com/google/re2/wiki/Syntax)
     *   does not match
     *   * `NOT` : Logical not
     *   * `AND` : Logical and
     *   * `OR` : Logical or
     *
     *   Examples:
     *
     *     1. `title="Holiday Sale"`
     *     2. `description=~"[Bb]ig [Gg]ame.*[Ss]ale"`
     *     3. `is_annotation_in_range("2025-12-25", "2026-01-16") = true`
     *     4. `annotation_duration() >= 172800s AND title:BOGO`
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages. If unspecified,
     *   at most 50 resources will be returned. The maximum value is 200; (higher
     *   values will be coerced to the maximum)
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `ListReportingDataAnnotations` call. Provide this to retrieve the
     *   subsequent page. When paginating, all other parameters provided to
     *   `ListReportingDataAnnotations` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.ReportingDataAnnotation|ReportingDataAnnotation} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listReportingDataAnnotationsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listReportingDataAnnotationsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listReportingDataAnnotations'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listReportingDataAnnotations stream %j', request);
        return this.descriptors.page.listReportingDataAnnotations.createStream(this.innerApiCalls.listReportingDataAnnotations, request, callSettings);
    }
    /**
     * Equivalent to `listReportingDataAnnotations`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Resource name of the property.
     *   Format: properties/property_id
     *   Example: properties/123
     * @param {string} [request.filter]
     *   Optional. Filter that restricts which reporting data annotations under the
     *   parent property are listed.
     *
     *   Supported fields are:
     *
     *     * 'name'
     *     * `title`
     *     * `description`
     *     * `annotation_date`
     *     * `annotation_date_range`
     *     * `color`
     *
     *   Additionally, this API provides the following helper functions:
     *
     *     * annotation_duration() : the duration that this annotation marks,
     *     [durations](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/duration.proto).
     *     expect a numeric representation of seconds followed by an `s` suffix.
     *     * is_annotation_in_range(start_date, end_date)  : if the annotation is in
     *     the range specified by the `start_date` and `end_date`. The dates are in
     *     ISO-8601 format, for example `2031-06-28`.
     *
     *   Supported operations:
     *
     *   * `=` : equals
     *   * `!=` : not equals
     *   * `<` : less than
     *   * `>` : greater than
     *   * `<=` :  less than or equals
     *   * `>=` : greater than or equals
     *   * `:` : has operator
     *   * `=~` : [regular expression](https://github.com/google/re2/wiki/Syntax)
     *   match
     *   * `!~` : [regular expression](https://github.com/google/re2/wiki/Syntax)
     *   does not match
     *   * `NOT` : Logical not
     *   * `AND` : Logical and
     *   * `OR` : Logical or
     *
     *   Examples:
     *
     *     1. `title="Holiday Sale"`
     *     2. `description=~"[Bb]ig [Gg]ame.*[Ss]ale"`
     *     3. `is_annotation_in_range("2025-12-25", "2026-01-16") = true`
     *     4. `annotation_duration() >= 172800s AND title:BOGO`
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages. If unspecified,
     *   at most 50 resources will be returned. The maximum value is 200; (higher
     *   values will be coerced to the maximum)
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `ListReportingDataAnnotations` call. Provide this to retrieve the
     *   subsequent page. When paginating, all other parameters provided to
     *   `ListReportingDataAnnotations` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.ReportingDataAnnotation|ReportingDataAnnotation}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_reporting_data_annotations.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListReportingDataAnnotations_async
     */
    listReportingDataAnnotationsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listReportingDataAnnotations'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listReportingDataAnnotations iterate %j', request);
        return this.descriptors.page.listReportingDataAnnotations.asyncIterate(this.innerApiCalls['listReportingDataAnnotations'], request, callSettings);
    }
    listSubpropertySyncConfigs(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        this.initialize().catch(err => { throw err; });
        const wrappedCallback = callback
            ? (error, values, nextPageRequest, rawResponse) => {
                this._log.info('listSubpropertySyncConfigs values %j', values);
                callback(error, values, nextPageRequest, rawResponse); // We verified callback above.
            }
            : undefined;
        this._log.info('listSubpropertySyncConfigs request %j', request);
        return this.innerApiCalls
            .listSubpropertySyncConfigs(request, options, wrappedCallback)
            ?.then(([response, input, output]) => {
            this._log.info('listSubpropertySyncConfigs values %j', response);
            return [response, input, output];
        });
    }
    /**
     * Equivalent to `listSubpropertySyncConfigs`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Resource name of the property.
     *   Format: properties/property_id
     *   Example: properties/123
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages. If unspecified,
     *   at most 50 resources will be returned. The maximum value is 200; (higher
     *   values will be coerced to the maximum)
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `ListSubpropertySyncConfig` call. Provide this to retrieve the subsequent
     *   page. When paginating, all other parameters provided to
     *   `ListSubpropertySyncConfig` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.analytics.admin.v1alpha.SubpropertySyncConfig|SubpropertySyncConfig} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listSubpropertySyncConfigsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */
    listSubpropertySyncConfigsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listSubpropertySyncConfigs'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listSubpropertySyncConfigs stream %j', request);
        return this.descriptors.page.listSubpropertySyncConfigs.createStream(this.innerApiCalls.listSubpropertySyncConfigs, request, callSettings);
    }
    /**
     * Equivalent to `listSubpropertySyncConfigs`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. Resource name of the property.
     *   Format: properties/property_id
     *   Example: properties/123
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of resources to return. The service may return
     *   fewer than this value, even if there are additional pages. If unspecified,
     *   at most 50 resources will be returned. The maximum value is 200; (higher
     *   values will be coerced to the maximum)
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous
     *   `ListSubpropertySyncConfig` call. Provide this to retrieve the subsequent
     *   page. When paginating, all other parameters provided to
     *   `ListSubpropertySyncConfig` must match the call that provided the page
     *   token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.analytics.admin.v1alpha.SubpropertySyncConfig|SubpropertySyncConfig}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1alpha/analytics_admin_service.list_subproperty_sync_configs.js</caption>
     * region_tag:analyticsadmin_v1alpha_generated_AnalyticsAdminService_ListSubpropertySyncConfigs_async
     */
    listSubpropertySyncConfigsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'parent': request.parent ?? '',
        });
        const defaultCallSettings = this._defaults['listSubpropertySyncConfigs'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize().catch(err => { throw err; });
        this._log.info('listSubpropertySyncConfigs iterate %j', request);
        return this.descriptors.page.listSubpropertySyncConfigs.asyncIterate(this.innerApiCalls['listSubpropertySyncConfigs'], request, callSettings);
    }
    // --------------------
    // -- Path templates --
    // --------------------
    /**
     * Return a fully-qualified account resource name string.
     *
     * @param {string} account
     * @returns {string} Resource name string.
     */
    accountPath(account) {
        return this.pathTemplates.accountPathTemplate.render({
            account: account,
        });
    }
    /**
     * Parse the account from Account resource.
     *
     * @param {string} accountName
     *   A fully-qualified path representing Account resource.
     * @returns {string} A string representing the account.
     */
    matchAccountFromAccountName(accountName) {
        return this.pathTemplates.accountPathTemplate.match(accountName).account;
    }
    /**
     * Return a fully-qualified accountAccessBinding resource name string.
     *
     * @param {string} account
     * @param {string} access_binding
     * @returns {string} Resource name string.
     */
    accountAccessBindingPath(account, accessBinding) {
        return this.pathTemplates.accountAccessBindingPathTemplate.render({
            account: account,
            access_binding: accessBinding,
        });
    }
    /**
     * Parse the account from AccountAccessBinding resource.
     *
     * @param {string} accountAccessBindingName
     *   A fully-qualified path representing account_access_binding resource.
     * @returns {string} A string representing the account.
     */
    matchAccountFromAccountAccessBindingName(accountAccessBindingName) {
        return this.pathTemplates.accountAccessBindingPathTemplate.match(accountAccessBindingName).account;
    }
    /**
     * Parse the access_binding from AccountAccessBinding resource.
     *
     * @param {string} accountAccessBindingName
     *   A fully-qualified path representing account_access_binding resource.
     * @returns {string} A string representing the access_binding.
     */
    matchAccessBindingFromAccountAccessBindingName(accountAccessBindingName) {
        return this.pathTemplates.accountAccessBindingPathTemplate.match(accountAccessBindingName).access_binding;
    }
    /**
     * Return a fully-qualified accountSummary resource name string.
     *
     * @param {string} account_summary
     * @returns {string} Resource name string.
     */
    accountSummaryPath(accountSummary) {
        return this.pathTemplates.accountSummaryPathTemplate.render({
            account_summary: accountSummary,
        });
    }
    /**
     * Parse the account_summary from AccountSummary resource.
     *
     * @param {string} accountSummaryName
     *   A fully-qualified path representing AccountSummary resource.
     * @returns {string} A string representing the account_summary.
     */
    matchAccountSummaryFromAccountSummaryName(accountSummaryName) {
        return this.pathTemplates.accountSummaryPathTemplate.match(accountSummaryName).account_summary;
    }
    /**
     * Return a fully-qualified adSenseLink resource name string.
     *
     * @param {string} property
     * @param {string} adsense_link
     * @returns {string} Resource name string.
     */
    adSenseLinkPath(property, adsenseLink) {
        return this.pathTemplates.adSenseLinkPathTemplate.render({
            property: property,
            adsense_link: adsenseLink,
        });
    }
    /**
     * Parse the property from AdSenseLink resource.
     *
     * @param {string} adSenseLinkName
     *   A fully-qualified path representing AdSenseLink resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromAdSenseLinkName(adSenseLinkName) {
        return this.pathTemplates.adSenseLinkPathTemplate.match(adSenseLinkName).property;
    }
    /**
     * Parse the adsense_link from AdSenseLink resource.
     *
     * @param {string} adSenseLinkName
     *   A fully-qualified path representing AdSenseLink resource.
     * @returns {string} A string representing the adsense_link.
     */
    matchAdsenseLinkFromAdSenseLinkName(adSenseLinkName) {
        return this.pathTemplates.adSenseLinkPathTemplate.match(adSenseLinkName).adsense_link;
    }
    /**
     * Return a fully-qualified attributionSettings resource name string.
     *
     * @param {string} property
     * @returns {string} Resource name string.
     */
    attributionSettingsPath(property) {
        return this.pathTemplates.attributionSettingsPathTemplate.render({
            property: property,
        });
    }
    /**
     * Parse the property from AttributionSettings resource.
     *
     * @param {string} attributionSettingsName
     *   A fully-qualified path representing AttributionSettings resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromAttributionSettingsName(attributionSettingsName) {
        return this.pathTemplates.attributionSettingsPathTemplate.match(attributionSettingsName).property;
    }
    /**
     * Return a fully-qualified audience resource name string.
     *
     * @param {string} property
     * @param {string} audience
     * @returns {string} Resource name string.
     */
    audiencePath(property, audience) {
        return this.pathTemplates.audiencePathTemplate.render({
            property: property,
            audience: audience,
        });
    }
    /**
     * Parse the property from Audience resource.
     *
     * @param {string} audienceName
     *   A fully-qualified path representing Audience resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromAudienceName(audienceName) {
        return this.pathTemplates.audiencePathTemplate.match(audienceName).property;
    }
    /**
     * Parse the audience from Audience resource.
     *
     * @param {string} audienceName
     *   A fully-qualified path representing Audience resource.
     * @returns {string} A string representing the audience.
     */
    matchAudienceFromAudienceName(audienceName) {
        return this.pathTemplates.audiencePathTemplate.match(audienceName).audience;
    }
    /**
     * Return a fully-qualified bigQueryLink resource name string.
     *
     * @param {string} property
     * @param {string} bigquery_link
     * @returns {string} Resource name string.
     */
    bigQueryLinkPath(property, bigqueryLink) {
        return this.pathTemplates.bigQueryLinkPathTemplate.render({
            property: property,
            bigquery_link: bigqueryLink,
        });
    }
    /**
     * Parse the property from BigQueryLink resource.
     *
     * @param {string} bigQueryLinkName
     *   A fully-qualified path representing BigQueryLink resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromBigQueryLinkName(bigQueryLinkName) {
        return this.pathTemplates.bigQueryLinkPathTemplate.match(bigQueryLinkName).property;
    }
    /**
     * Parse the bigquery_link from BigQueryLink resource.
     *
     * @param {string} bigQueryLinkName
     *   A fully-qualified path representing BigQueryLink resource.
     * @returns {string} A string representing the bigquery_link.
     */
    matchBigqueryLinkFromBigQueryLinkName(bigQueryLinkName) {
        return this.pathTemplates.bigQueryLinkPathTemplate.match(bigQueryLinkName).bigquery_link;
    }
    /**
     * Return a fully-qualified calculatedMetric resource name string.
     *
     * @param {string} property
     * @param {string} calculated_metric
     * @returns {string} Resource name string.
     */
    calculatedMetricPath(property, calculatedMetric) {
        return this.pathTemplates.calculatedMetricPathTemplate.render({
            property: property,
            calculated_metric: calculatedMetric,
        });
    }
    /**
     * Parse the property from CalculatedMetric resource.
     *
     * @param {string} calculatedMetricName
     *   A fully-qualified path representing CalculatedMetric resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromCalculatedMetricName(calculatedMetricName) {
        return this.pathTemplates.calculatedMetricPathTemplate.match(calculatedMetricName).property;
    }
    /**
     * Parse the calculated_metric from CalculatedMetric resource.
     *
     * @param {string} calculatedMetricName
     *   A fully-qualified path representing CalculatedMetric resource.
     * @returns {string} A string representing the calculated_metric.
     */
    matchCalculatedMetricFromCalculatedMetricName(calculatedMetricName) {
        return this.pathTemplates.calculatedMetricPathTemplate.match(calculatedMetricName).calculated_metric;
    }
    /**
     * Return a fully-qualified channelGroup resource name string.
     *
     * @param {string} property
     * @param {string} channel_group
     * @returns {string} Resource name string.
     */
    channelGroupPath(property, channelGroup) {
        return this.pathTemplates.channelGroupPathTemplate.render({
            property: property,
            channel_group: channelGroup,
        });
    }
    /**
     * Parse the property from ChannelGroup resource.
     *
     * @param {string} channelGroupName
     *   A fully-qualified path representing ChannelGroup resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromChannelGroupName(channelGroupName) {
        return this.pathTemplates.channelGroupPathTemplate.match(channelGroupName).property;
    }
    /**
     * Parse the channel_group from ChannelGroup resource.
     *
     * @param {string} channelGroupName
     *   A fully-qualified path representing ChannelGroup resource.
     * @returns {string} A string representing the channel_group.
     */
    matchChannelGroupFromChannelGroupName(channelGroupName) {
        return this.pathTemplates.channelGroupPathTemplate.match(channelGroupName).channel_group;
    }
    /**
     * Return a fully-qualified conversionEvent resource name string.
     *
     * @param {string} property
     * @param {string} conversion_event
     * @returns {string} Resource name string.
     */
    conversionEventPath(property, conversionEvent) {
        return this.pathTemplates.conversionEventPathTemplate.render({
            property: property,
            conversion_event: conversionEvent,
        });
    }
    /**
     * Parse the property from ConversionEvent resource.
     *
     * @param {string} conversionEventName
     *   A fully-qualified path representing ConversionEvent resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromConversionEventName(conversionEventName) {
        return this.pathTemplates.conversionEventPathTemplate.match(conversionEventName).property;
    }
    /**
     * Parse the conversion_event from ConversionEvent resource.
     *
     * @param {string} conversionEventName
     *   A fully-qualified path representing ConversionEvent resource.
     * @returns {string} A string representing the conversion_event.
     */
    matchConversionEventFromConversionEventName(conversionEventName) {
        return this.pathTemplates.conversionEventPathTemplate.match(conversionEventName).conversion_event;
    }
    /**
     * Return a fully-qualified customDimension resource name string.
     *
     * @param {string} property
     * @param {string} custom_dimension
     * @returns {string} Resource name string.
     */
    customDimensionPath(property, customDimension) {
        return this.pathTemplates.customDimensionPathTemplate.render({
            property: property,
            custom_dimension: customDimension,
        });
    }
    /**
     * Parse the property from CustomDimension resource.
     *
     * @param {string} customDimensionName
     *   A fully-qualified path representing CustomDimension resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromCustomDimensionName(customDimensionName) {
        return this.pathTemplates.customDimensionPathTemplate.match(customDimensionName).property;
    }
    /**
     * Parse the custom_dimension from CustomDimension resource.
     *
     * @param {string} customDimensionName
     *   A fully-qualified path representing CustomDimension resource.
     * @returns {string} A string representing the custom_dimension.
     */
    matchCustomDimensionFromCustomDimensionName(customDimensionName) {
        return this.pathTemplates.customDimensionPathTemplate.match(customDimensionName).custom_dimension;
    }
    /**
     * Return a fully-qualified customMetric resource name string.
     *
     * @param {string} property
     * @param {string} custom_metric
     * @returns {string} Resource name string.
     */
    customMetricPath(property, customMetric) {
        return this.pathTemplates.customMetricPathTemplate.render({
            property: property,
            custom_metric: customMetric,
        });
    }
    /**
     * Parse the property from CustomMetric resource.
     *
     * @param {string} customMetricName
     *   A fully-qualified path representing CustomMetric resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromCustomMetricName(customMetricName) {
        return this.pathTemplates.customMetricPathTemplate.match(customMetricName).property;
    }
    /**
     * Parse the custom_metric from CustomMetric resource.
     *
     * @param {string} customMetricName
     *   A fully-qualified path representing CustomMetric resource.
     * @returns {string} A string representing the custom_metric.
     */
    matchCustomMetricFromCustomMetricName(customMetricName) {
        return this.pathTemplates.customMetricPathTemplate.match(customMetricName).custom_metric;
    }
    /**
     * Return a fully-qualified dataRedactionSettings resource name string.
     *
     * @param {string} property
     * @param {string} data_stream
     * @returns {string} Resource name string.
     */
    dataRedactionSettingsPath(property, dataStream) {
        return this.pathTemplates.dataRedactionSettingsPathTemplate.render({
            property: property,
            data_stream: dataStream,
        });
    }
    /**
     * Parse the property from DataRedactionSettings resource.
     *
     * @param {string} dataRedactionSettingsName
     *   A fully-qualified path representing DataRedactionSettings resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromDataRedactionSettingsName(dataRedactionSettingsName) {
        return this.pathTemplates.dataRedactionSettingsPathTemplate.match(dataRedactionSettingsName).property;
    }
    /**
     * Parse the data_stream from DataRedactionSettings resource.
     *
     * @param {string} dataRedactionSettingsName
     *   A fully-qualified path representing DataRedactionSettings resource.
     * @returns {string} A string representing the data_stream.
     */
    matchDataStreamFromDataRedactionSettingsName(dataRedactionSettingsName) {
        return this.pathTemplates.dataRedactionSettingsPathTemplate.match(dataRedactionSettingsName).data_stream;
    }
    /**
     * Return a fully-qualified dataRetentionSettings resource name string.
     *
     * @param {string} property
     * @returns {string} Resource name string.
     */
    dataRetentionSettingsPath(property) {
        return this.pathTemplates.dataRetentionSettingsPathTemplate.render({
            property: property,
        });
    }
    /**
     * Parse the property from DataRetentionSettings resource.
     *
     * @param {string} dataRetentionSettingsName
     *   A fully-qualified path representing DataRetentionSettings resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromDataRetentionSettingsName(dataRetentionSettingsName) {
        return this.pathTemplates.dataRetentionSettingsPathTemplate.match(dataRetentionSettingsName).property;
    }
    /**
     * Return a fully-qualified dataSharingSettings resource name string.
     *
     * @param {string} account
     * @returns {string} Resource name string.
     */
    dataSharingSettingsPath(account) {
        return this.pathTemplates.dataSharingSettingsPathTemplate.render({
            account: account,
        });
    }
    /**
     * Parse the account from DataSharingSettings resource.
     *
     * @param {string} dataSharingSettingsName
     *   A fully-qualified path representing DataSharingSettings resource.
     * @returns {string} A string representing the account.
     */
    matchAccountFromDataSharingSettingsName(dataSharingSettingsName) {
        return this.pathTemplates.dataSharingSettingsPathTemplate.match(dataSharingSettingsName).account;
    }
    /**
     * Return a fully-qualified dataStream resource name string.
     *
     * @param {string} property
     * @param {string} data_stream
     * @returns {string} Resource name string.
     */
    dataStreamPath(property, dataStream) {
        return this.pathTemplates.dataStreamPathTemplate.render({
            property: property,
            data_stream: dataStream,
        });
    }
    /**
     * Parse the property from DataStream resource.
     *
     * @param {string} dataStreamName
     *   A fully-qualified path representing DataStream resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromDataStreamName(dataStreamName) {
        return this.pathTemplates.dataStreamPathTemplate.match(dataStreamName).property;
    }
    /**
     * Parse the data_stream from DataStream resource.
     *
     * @param {string} dataStreamName
     *   A fully-qualified path representing DataStream resource.
     * @returns {string} A string representing the data_stream.
     */
    matchDataStreamFromDataStreamName(dataStreamName) {
        return this.pathTemplates.dataStreamPathTemplate.match(dataStreamName).data_stream;
    }
    /**
     * Return a fully-qualified displayVideo360AdvertiserLink resource name string.
     *
     * @param {string} property
     * @returns {string} Resource name string.
     */
    displayVideo360AdvertiserLinkPath(property) {
        return this.pathTemplates.displayVideo360AdvertiserLinkPathTemplate.render({
            property: property,
        });
    }
    /**
     * Parse the property from DisplayVideo360AdvertiserLink resource.
     *
     * @param {string} displayVideo360AdvertiserLinkName
     *   A fully-qualified path representing DisplayVideo360AdvertiserLink resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromDisplayVideo360AdvertiserLinkName(displayVideo360AdvertiserLinkName) {
        return this.pathTemplates.displayVideo360AdvertiserLinkPathTemplate.match(displayVideo360AdvertiserLinkName).property;
    }
    /**
     * Return a fully-qualified displayVideo360AdvertiserLinkProposal resource name string.
     *
     * @param {string} property
     * @returns {string} Resource name string.
     */
    displayVideo360AdvertiserLinkProposalPath(property) {
        return this.pathTemplates.displayVideo360AdvertiserLinkProposalPathTemplate.render({
            property: property,
        });
    }
    /**
     * Parse the property from DisplayVideo360AdvertiserLinkProposal resource.
     *
     * @param {string} displayVideo360AdvertiserLinkProposalName
     *   A fully-qualified path representing DisplayVideo360AdvertiserLinkProposal resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromDisplayVideo360AdvertiserLinkProposalName(displayVideo360AdvertiserLinkProposalName) {
        return this.pathTemplates.displayVideo360AdvertiserLinkProposalPathTemplate.match(displayVideo360AdvertiserLinkProposalName).property;
    }
    /**
     * Return a fully-qualified enhancedMeasurementSettings resource name string.
     *
     * @param {string} property
     * @param {string} data_stream
     * @returns {string} Resource name string.
     */
    enhancedMeasurementSettingsPath(property, dataStream) {
        return this.pathTemplates.enhancedMeasurementSettingsPathTemplate.render({
            property: property,
            data_stream: dataStream,
        });
    }
    /**
     * Parse the property from EnhancedMeasurementSettings resource.
     *
     * @param {string} enhancedMeasurementSettingsName
     *   A fully-qualified path representing EnhancedMeasurementSettings resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromEnhancedMeasurementSettingsName(enhancedMeasurementSettingsName) {
        return this.pathTemplates.enhancedMeasurementSettingsPathTemplate.match(enhancedMeasurementSettingsName).property;
    }
    /**
     * Parse the data_stream from EnhancedMeasurementSettings resource.
     *
     * @param {string} enhancedMeasurementSettingsName
     *   A fully-qualified path representing EnhancedMeasurementSettings resource.
     * @returns {string} A string representing the data_stream.
     */
    matchDataStreamFromEnhancedMeasurementSettingsName(enhancedMeasurementSettingsName) {
        return this.pathTemplates.enhancedMeasurementSettingsPathTemplate.match(enhancedMeasurementSettingsName).data_stream;
    }
    /**
     * Return a fully-qualified eventCreateRule resource name string.
     *
     * @param {string} property
     * @param {string} data_stream
     * @param {string} event_create_rule
     * @returns {string} Resource name string.
     */
    eventCreateRulePath(property, dataStream, eventCreateRule) {
        return this.pathTemplates.eventCreateRulePathTemplate.render({
            property: property,
            data_stream: dataStream,
            event_create_rule: eventCreateRule,
        });
    }
    /**
     * Parse the property from EventCreateRule resource.
     *
     * @param {string} eventCreateRuleName
     *   A fully-qualified path representing EventCreateRule resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromEventCreateRuleName(eventCreateRuleName) {
        return this.pathTemplates.eventCreateRulePathTemplate.match(eventCreateRuleName).property;
    }
    /**
     * Parse the data_stream from EventCreateRule resource.
     *
     * @param {string} eventCreateRuleName
     *   A fully-qualified path representing EventCreateRule resource.
     * @returns {string} A string representing the data_stream.
     */
    matchDataStreamFromEventCreateRuleName(eventCreateRuleName) {
        return this.pathTemplates.eventCreateRulePathTemplate.match(eventCreateRuleName).data_stream;
    }
    /**
     * Parse the event_create_rule from EventCreateRule resource.
     *
     * @param {string} eventCreateRuleName
     *   A fully-qualified path representing EventCreateRule resource.
     * @returns {string} A string representing the event_create_rule.
     */
    matchEventCreateRuleFromEventCreateRuleName(eventCreateRuleName) {
        return this.pathTemplates.eventCreateRulePathTemplate.match(eventCreateRuleName).event_create_rule;
    }
    /**
     * Return a fully-qualified eventEditRule resource name string.
     *
     * @param {string} property
     * @param {string} data_stream
     * @param {string} event_edit_rule
     * @returns {string} Resource name string.
     */
    eventEditRulePath(property, dataStream, eventEditRule) {
        return this.pathTemplates.eventEditRulePathTemplate.render({
            property: property,
            data_stream: dataStream,
            event_edit_rule: eventEditRule,
        });
    }
    /**
     * Parse the property from EventEditRule resource.
     *
     * @param {string} eventEditRuleName
     *   A fully-qualified path representing EventEditRule resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromEventEditRuleName(eventEditRuleName) {
        return this.pathTemplates.eventEditRulePathTemplate.match(eventEditRuleName).property;
    }
    /**
     * Parse the data_stream from EventEditRule resource.
     *
     * @param {string} eventEditRuleName
     *   A fully-qualified path representing EventEditRule resource.
     * @returns {string} A string representing the data_stream.
     */
    matchDataStreamFromEventEditRuleName(eventEditRuleName) {
        return this.pathTemplates.eventEditRulePathTemplate.match(eventEditRuleName).data_stream;
    }
    /**
     * Parse the event_edit_rule from EventEditRule resource.
     *
     * @param {string} eventEditRuleName
     *   A fully-qualified path representing EventEditRule resource.
     * @returns {string} A string representing the event_edit_rule.
     */
    matchEventEditRuleFromEventEditRuleName(eventEditRuleName) {
        return this.pathTemplates.eventEditRulePathTemplate.match(eventEditRuleName).event_edit_rule;
    }
    /**
     * Return a fully-qualified expandedDataSet resource name string.
     *
     * @param {string} property
     * @param {string} expanded_data_set
     * @returns {string} Resource name string.
     */
    expandedDataSetPath(property, expandedDataSet) {
        return this.pathTemplates.expandedDataSetPathTemplate.render({
            property: property,
            expanded_data_set: expandedDataSet,
        });
    }
    /**
     * Parse the property from ExpandedDataSet resource.
     *
     * @param {string} expandedDataSetName
     *   A fully-qualified path representing ExpandedDataSet resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromExpandedDataSetName(expandedDataSetName) {
        return this.pathTemplates.expandedDataSetPathTemplate.match(expandedDataSetName).property;
    }
    /**
     * Parse the expanded_data_set from ExpandedDataSet resource.
     *
     * @param {string} expandedDataSetName
     *   A fully-qualified path representing ExpandedDataSet resource.
     * @returns {string} A string representing the expanded_data_set.
     */
    matchExpandedDataSetFromExpandedDataSetName(expandedDataSetName) {
        return this.pathTemplates.expandedDataSetPathTemplate.match(expandedDataSetName).expanded_data_set;
    }
    /**
     * Return a fully-qualified firebaseLink resource name string.
     *
     * @param {string} property
     * @param {string} firebase_link
     * @returns {string} Resource name string.
     */
    firebaseLinkPath(property, firebaseLink) {
        return this.pathTemplates.firebaseLinkPathTemplate.render({
            property: property,
            firebase_link: firebaseLink,
        });
    }
    /**
     * Parse the property from FirebaseLink resource.
     *
     * @param {string} firebaseLinkName
     *   A fully-qualified path representing FirebaseLink resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromFirebaseLinkName(firebaseLinkName) {
        return this.pathTemplates.firebaseLinkPathTemplate.match(firebaseLinkName).property;
    }
    /**
     * Parse the firebase_link from FirebaseLink resource.
     *
     * @param {string} firebaseLinkName
     *   A fully-qualified path representing FirebaseLink resource.
     * @returns {string} A string representing the firebase_link.
     */
    matchFirebaseLinkFromFirebaseLinkName(firebaseLinkName) {
        return this.pathTemplates.firebaseLinkPathTemplate.match(firebaseLinkName).firebase_link;
    }
    /**
     * Return a fully-qualified globalSiteTag resource name string.
     *
     * @param {string} property
     * @param {string} data_stream
     * @returns {string} Resource name string.
     */
    globalSiteTagPath(property, dataStream) {
        return this.pathTemplates.globalSiteTagPathTemplate.render({
            property: property,
            data_stream: dataStream,
        });
    }
    /**
     * Parse the property from GlobalSiteTag resource.
     *
     * @param {string} globalSiteTagName
     *   A fully-qualified path representing GlobalSiteTag resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromGlobalSiteTagName(globalSiteTagName) {
        return this.pathTemplates.globalSiteTagPathTemplate.match(globalSiteTagName).property;
    }
    /**
     * Parse the data_stream from GlobalSiteTag resource.
     *
     * @param {string} globalSiteTagName
     *   A fully-qualified path representing GlobalSiteTag resource.
     * @returns {string} A string representing the data_stream.
     */
    matchDataStreamFromGlobalSiteTagName(globalSiteTagName) {
        return this.pathTemplates.globalSiteTagPathTemplate.match(globalSiteTagName).data_stream;
    }
    /**
     * Return a fully-qualified googleAdsLink resource name string.
     *
     * @param {string} property
     * @param {string} google_ads_link
     * @returns {string} Resource name string.
     */
    googleAdsLinkPath(property, googleAdsLink) {
        return this.pathTemplates.googleAdsLinkPathTemplate.render({
            property: property,
            google_ads_link: googleAdsLink,
        });
    }
    /**
     * Parse the property from GoogleAdsLink resource.
     *
     * @param {string} googleAdsLinkName
     *   A fully-qualified path representing GoogleAdsLink resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromGoogleAdsLinkName(googleAdsLinkName) {
        return this.pathTemplates.googleAdsLinkPathTemplate.match(googleAdsLinkName).property;
    }
    /**
     * Parse the google_ads_link from GoogleAdsLink resource.
     *
     * @param {string} googleAdsLinkName
     *   A fully-qualified path representing GoogleAdsLink resource.
     * @returns {string} A string representing the google_ads_link.
     */
    matchGoogleAdsLinkFromGoogleAdsLinkName(googleAdsLinkName) {
        return this.pathTemplates.googleAdsLinkPathTemplate.match(googleAdsLinkName).google_ads_link;
    }
    /**
     * Return a fully-qualified googleSignalsSettings resource name string.
     *
     * @param {string} property
     * @returns {string} Resource name string.
     */
    googleSignalsSettingsPath(property) {
        return this.pathTemplates.googleSignalsSettingsPathTemplate.render({
            property: property,
        });
    }
    /**
     * Parse the property from GoogleSignalsSettings resource.
     *
     * @param {string} googleSignalsSettingsName
     *   A fully-qualified path representing GoogleSignalsSettings resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromGoogleSignalsSettingsName(googleSignalsSettingsName) {
        return this.pathTemplates.googleSignalsSettingsPathTemplate.match(googleSignalsSettingsName).property;
    }
    /**
     * Return a fully-qualified keyEvent resource name string.
     *
     * @param {string} property
     * @param {string} key_event
     * @returns {string} Resource name string.
     */
    keyEventPath(property, keyEvent) {
        return this.pathTemplates.keyEventPathTemplate.render({
            property: property,
            key_event: keyEvent,
        });
    }
    /**
     * Parse the property from KeyEvent resource.
     *
     * @param {string} keyEventName
     *   A fully-qualified path representing KeyEvent resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromKeyEventName(keyEventName) {
        return this.pathTemplates.keyEventPathTemplate.match(keyEventName).property;
    }
    /**
     * Parse the key_event from KeyEvent resource.
     *
     * @param {string} keyEventName
     *   A fully-qualified path representing KeyEvent resource.
     * @returns {string} A string representing the key_event.
     */
    matchKeyEventFromKeyEventName(keyEventName) {
        return this.pathTemplates.keyEventPathTemplate.match(keyEventName).key_event;
    }
    /**
     * Return a fully-qualified measurementProtocolSecret resource name string.
     *
     * @param {string} property
     * @param {string} data_stream
     * @param {string} measurement_protocol_secret
     * @returns {string} Resource name string.
     */
    measurementProtocolSecretPath(property, dataStream, measurementProtocolSecret) {
        return this.pathTemplates.measurementProtocolSecretPathTemplate.render({
            property: property,
            data_stream: dataStream,
            measurement_protocol_secret: measurementProtocolSecret,
        });
    }
    /**
     * Parse the property from MeasurementProtocolSecret resource.
     *
     * @param {string} measurementProtocolSecretName
     *   A fully-qualified path representing MeasurementProtocolSecret resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromMeasurementProtocolSecretName(measurementProtocolSecretName) {
        return this.pathTemplates.measurementProtocolSecretPathTemplate.match(measurementProtocolSecretName).property;
    }
    /**
     * Parse the data_stream from MeasurementProtocolSecret resource.
     *
     * @param {string} measurementProtocolSecretName
     *   A fully-qualified path representing MeasurementProtocolSecret resource.
     * @returns {string} A string representing the data_stream.
     */
    matchDataStreamFromMeasurementProtocolSecretName(measurementProtocolSecretName) {
        return this.pathTemplates.measurementProtocolSecretPathTemplate.match(measurementProtocolSecretName).data_stream;
    }
    /**
     * Parse the measurement_protocol_secret from MeasurementProtocolSecret resource.
     *
     * @param {string} measurementProtocolSecretName
     *   A fully-qualified path representing MeasurementProtocolSecret resource.
     * @returns {string} A string representing the measurement_protocol_secret.
     */
    matchMeasurementProtocolSecretFromMeasurementProtocolSecretName(measurementProtocolSecretName) {
        return this.pathTemplates.measurementProtocolSecretPathTemplate.match(measurementProtocolSecretName).measurement_protocol_secret;
    }
    /**
     * Return a fully-qualified property resource name string.
     *
     * @param {string} property
     * @returns {string} Resource name string.
     */
    propertyPath(property) {
        return this.pathTemplates.propertyPathTemplate.render({
            property: property,
        });
    }
    /**
     * Parse the property from Property resource.
     *
     * @param {string} propertyName
     *   A fully-qualified path representing Property resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromPropertyName(propertyName) {
        return this.pathTemplates.propertyPathTemplate.match(propertyName).property;
    }
    /**
     * Return a fully-qualified propertyAccessBinding resource name string.
     *
     * @param {string} property
     * @param {string} access_binding
     * @returns {string} Resource name string.
     */
    propertyAccessBindingPath(property, accessBinding) {
        return this.pathTemplates.propertyAccessBindingPathTemplate.render({
            property: property,
            access_binding: accessBinding,
        });
    }
    /**
     * Parse the property from PropertyAccessBinding resource.
     *
     * @param {string} propertyAccessBindingName
     *   A fully-qualified path representing property_access_binding resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromPropertyAccessBindingName(propertyAccessBindingName) {
        return this.pathTemplates.propertyAccessBindingPathTemplate.match(propertyAccessBindingName).property;
    }
    /**
     * Parse the access_binding from PropertyAccessBinding resource.
     *
     * @param {string} propertyAccessBindingName
     *   A fully-qualified path representing property_access_binding resource.
     * @returns {string} A string representing the access_binding.
     */
    matchAccessBindingFromPropertyAccessBindingName(propertyAccessBindingName) {
        return this.pathTemplates.propertyAccessBindingPathTemplate.match(propertyAccessBindingName).access_binding;
    }
    /**
     * Return a fully-qualified reportingDataAnnotation resource name string.
     *
     * @param {string} property
     * @param {string} reporting_data_annotation
     * @returns {string} Resource name string.
     */
    reportingDataAnnotationPath(property, reportingDataAnnotation) {
        return this.pathTemplates.reportingDataAnnotationPathTemplate.render({
            property: property,
            reporting_data_annotation: reportingDataAnnotation,
        });
    }
    /**
     * Parse the property from ReportingDataAnnotation resource.
     *
     * @param {string} reportingDataAnnotationName
     *   A fully-qualified path representing ReportingDataAnnotation resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromReportingDataAnnotationName(reportingDataAnnotationName) {
        return this.pathTemplates.reportingDataAnnotationPathTemplate.match(reportingDataAnnotationName).property;
    }
    /**
     * Parse the reporting_data_annotation from ReportingDataAnnotation resource.
     *
     * @param {string} reportingDataAnnotationName
     *   A fully-qualified path representing ReportingDataAnnotation resource.
     * @returns {string} A string representing the reporting_data_annotation.
     */
    matchReportingDataAnnotationFromReportingDataAnnotationName(reportingDataAnnotationName) {
        return this.pathTemplates.reportingDataAnnotationPathTemplate.match(reportingDataAnnotationName).reporting_data_annotation;
    }
    /**
     * Return a fully-qualified reportingIdentitySettings resource name string.
     *
     * @param {string} property
     * @returns {string} Resource name string.
     */
    reportingIdentitySettingsPath(property) {
        return this.pathTemplates.reportingIdentitySettingsPathTemplate.render({
            property: property,
        });
    }
    /**
     * Parse the property from ReportingIdentitySettings resource.
     *
     * @param {string} reportingIdentitySettingsName
     *   A fully-qualified path representing ReportingIdentitySettings resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromReportingIdentitySettingsName(reportingIdentitySettingsName) {
        return this.pathTemplates.reportingIdentitySettingsPathTemplate.match(reportingIdentitySettingsName).property;
    }
    /**
     * Return a fully-qualified rollupPropertySourceLink resource name string.
     *
     * @param {string} property
     * @param {string} rollup_property_source_link
     * @returns {string} Resource name string.
     */
    rollupPropertySourceLinkPath(property, rollupPropertySourceLink) {
        return this.pathTemplates.rollupPropertySourceLinkPathTemplate.render({
            property: property,
            rollup_property_source_link: rollupPropertySourceLink,
        });
    }
    /**
     * Parse the property from RollupPropertySourceLink resource.
     *
     * @param {string} rollupPropertySourceLinkName
     *   A fully-qualified path representing RollupPropertySourceLink resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromRollupPropertySourceLinkName(rollupPropertySourceLinkName) {
        return this.pathTemplates.rollupPropertySourceLinkPathTemplate.match(rollupPropertySourceLinkName).property;
    }
    /**
     * Parse the rollup_property_source_link from RollupPropertySourceLink resource.
     *
     * @param {string} rollupPropertySourceLinkName
     *   A fully-qualified path representing RollupPropertySourceLink resource.
     * @returns {string} A string representing the rollup_property_source_link.
     */
    matchRollupPropertySourceLinkFromRollupPropertySourceLinkName(rollupPropertySourceLinkName) {
        return this.pathTemplates.rollupPropertySourceLinkPathTemplate.match(rollupPropertySourceLinkName).rollup_property_source_link;
    }
    /**
     * Return a fully-qualified sKAdNetworkConversionValueSchema resource name string.
     *
     * @param {string} property
     * @param {string} data_stream
     * @param {string} skadnetwork_conversion_value_schema
     * @returns {string} Resource name string.
     */
    sKAdNetworkConversionValueSchemaPath(property, dataStream, skadnetworkConversionValueSchema) {
        return this.pathTemplates.sKAdNetworkConversionValueSchemaPathTemplate.render({
            property: property,
            data_stream: dataStream,
            skadnetwork_conversion_value_schema: skadnetworkConversionValueSchema,
        });
    }
    /**
     * Parse the property from SKAdNetworkConversionValueSchema resource.
     *
     * @param {string} sKAdNetworkConversionValueSchemaName
     *   A fully-qualified path representing SKAdNetworkConversionValueSchema resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromSKAdNetworkConversionValueSchemaName(sKAdNetworkConversionValueSchemaName) {
        return this.pathTemplates.sKAdNetworkConversionValueSchemaPathTemplate.match(sKAdNetworkConversionValueSchemaName).property;
    }
    /**
     * Parse the data_stream from SKAdNetworkConversionValueSchema resource.
     *
     * @param {string} sKAdNetworkConversionValueSchemaName
     *   A fully-qualified path representing SKAdNetworkConversionValueSchema resource.
     * @returns {string} A string representing the data_stream.
     */
    matchDataStreamFromSKAdNetworkConversionValueSchemaName(sKAdNetworkConversionValueSchemaName) {
        return this.pathTemplates.sKAdNetworkConversionValueSchemaPathTemplate.match(sKAdNetworkConversionValueSchemaName).data_stream;
    }
    /**
     * Parse the skadnetwork_conversion_value_schema from SKAdNetworkConversionValueSchema resource.
     *
     * @param {string} sKAdNetworkConversionValueSchemaName
     *   A fully-qualified path representing SKAdNetworkConversionValueSchema resource.
     * @returns {string} A string representing the skadnetwork_conversion_value_schema.
     */
    matchSkadnetworkConversionValueSchemaFromSKAdNetworkConversionValueSchemaName(sKAdNetworkConversionValueSchemaName) {
        return this.pathTemplates.sKAdNetworkConversionValueSchemaPathTemplate.match(sKAdNetworkConversionValueSchemaName).skadnetwork_conversion_value_schema;
    }
    /**
     * Return a fully-qualified searchAds360Link resource name string.
     *
     * @param {string} property
     * @returns {string} Resource name string.
     */
    searchAds360LinkPath(property) {
        return this.pathTemplates.searchAds360LinkPathTemplate.render({
            property: property,
        });
    }
    /**
     * Parse the property from SearchAds360Link resource.
     *
     * @param {string} searchAds360LinkName
     *   A fully-qualified path representing SearchAds360Link resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromSearchAds360LinkName(searchAds360LinkName) {
        return this.pathTemplates.searchAds360LinkPathTemplate.match(searchAds360LinkName).property;
    }
    /**
     * Return a fully-qualified subpropertyEventFilter resource name string.
     *
     * @param {string} property
     * @param {string} sub_property_event_filter
     * @returns {string} Resource name string.
     */
    subpropertyEventFilterPath(property, subPropertyEventFilter) {
        return this.pathTemplates.subpropertyEventFilterPathTemplate.render({
            property: property,
            sub_property_event_filter: subPropertyEventFilter,
        });
    }
    /**
     * Parse the property from SubpropertyEventFilter resource.
     *
     * @param {string} subpropertyEventFilterName
     *   A fully-qualified path representing SubpropertyEventFilter resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromSubpropertyEventFilterName(subpropertyEventFilterName) {
        return this.pathTemplates.subpropertyEventFilterPathTemplate.match(subpropertyEventFilterName).property;
    }
    /**
     * Parse the sub_property_event_filter from SubpropertyEventFilter resource.
     *
     * @param {string} subpropertyEventFilterName
     *   A fully-qualified path representing SubpropertyEventFilter resource.
     * @returns {string} A string representing the sub_property_event_filter.
     */
    matchSubPropertyEventFilterFromSubpropertyEventFilterName(subpropertyEventFilterName) {
        return this.pathTemplates.subpropertyEventFilterPathTemplate.match(subpropertyEventFilterName).sub_property_event_filter;
    }
    /**
     * Return a fully-qualified subpropertySyncConfig resource name string.
     *
     * @param {string} property
     * @param {string} subproperty_sync_config
     * @returns {string} Resource name string.
     */
    subpropertySyncConfigPath(property, subpropertySyncConfig) {
        return this.pathTemplates.subpropertySyncConfigPathTemplate.render({
            property: property,
            subproperty_sync_config: subpropertySyncConfig,
        });
    }
    /**
     * Parse the property from SubpropertySyncConfig resource.
     *
     * @param {string} subpropertySyncConfigName
     *   A fully-qualified path representing SubpropertySyncConfig resource.
     * @returns {string} A string representing the property.
     */
    matchPropertyFromSubpropertySyncConfigName(subpropertySyncConfigName) {
        return this.pathTemplates.subpropertySyncConfigPathTemplate.match(subpropertySyncConfigName).property;
    }
    /**
     * Parse the subproperty_sync_config from SubpropertySyncConfig resource.
     *
     * @param {string} subpropertySyncConfigName
     *   A fully-qualified path representing SubpropertySyncConfig resource.
     * @returns {string} A string representing the subproperty_sync_config.
     */
    matchSubpropertySyncConfigFromSubpropertySyncConfigName(subpropertySyncConfigName) {
        return this.pathTemplates.subpropertySyncConfigPathTemplate.match(subpropertySyncConfigName).subproperty_sync_config;
    }
    /**
     * Terminate the gRPC channel and close the client.
     *
     * The client will no longer be usable and all future behavior is undefined.
     * @returns {Promise} A promise that resolves when the client is closed.
     */
    close() {
        if (this.analyticsAdminServiceStub && !this._terminated) {
            return this.analyticsAdminServiceStub.then(stub => {
                this._log.info('ending gRPC channel');
                this._terminated = true;
                stub.close();
            });
        }
        return Promise.resolve();
    }
}
exports.AnalyticsAdminServiceClient = AnalyticsAdminServiceClient;
//# sourceMappingURL=analytics_admin_service_client.js.map